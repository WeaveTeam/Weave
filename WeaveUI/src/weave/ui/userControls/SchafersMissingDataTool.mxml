<?xml version="1.0" encoding="utf-8"?>
<!--
/*
Weave (Web-based Analysis and Visualization Environment)
Copyright (C) 2008-2011 University of Massachusetts Lowell

This file is a part of Weave.

Weave is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License, Version 3,
as published by the Free Software Foundation.

Weave is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Weave.  If not, see <http://www.gnu.org/licenses/>.
*/
-->

<!--
SchafersMissingDataImputation

1. Pick your columns
2. Assign variable names to those columns
3. Input an R script using those variable names
4. List the outputs you want
5. The columns get joined on the client-side using the keys (record identifiers) to produce flat Arrays lined up by row index
6. These columns become the input to the R script on the server, the server runs the script and returns the results.
7. On the client side, any returned Arrays are matched up with the original keys using the same row order to become columns.
8. Any other results are just printed out to the text area.

@spurushe

-->
<DraggablePanel xmlns="weave.ui.*"
				xmlns:fx="http://ns.adobe.com/mxml/2009" 
				xmlns:s="library://ns.adobe.com/flex/spark" 
				xmlns:mx="library://ns.adobe.com/flex/mx"
				x="15%" y="15%" width="70%" height="70%" autoLayout="true" 
				implements="weave.api.ui.IVisTool" layout="{new HorizontalLayout()}"
				title="Schafers Missing Data Imputation"
				backgroundColor="0xEFF4BC">
	
	
	<s:HGroup width="100%" height="100%" paddingBottom="{padding}" paddingLeft="{padding}"
			  paddingRight="{padding}" paddingTop="{padding}">
		<s:VGroup width="20%" height="100%" gap="0">
			<s:Label text="(1) Select data to use in your script"/>
			<ColumnListComponent id="inputColumnList" width="100%" height="100%"
								 label="Input columns" hashMap="{variables}"/>			
		</s:VGroup>
		<s:VGroup id="vb" width="70%" height="100%" gap="0">
			<LabelWithWordWrap text="(2)Assign variable names and check Attributes for Missing Data"/>
			<mx:TextArea id="assignTA" width="50%" height="25%" wordWrap="false"/>
			<s:Spacer height="{padding}"/>
			<s:VGroup width="100%">
				<LabelWithWordWrap text="(3)Check if selected columns have missing data"/>
				<s:Button id="checkforNA" label="Check dataset for missing data?"
						  buttonDown="imputing_buttonDownHandler(event)"/>	
			</s:VGroup>
			<s:Spacer height="{padding}"/>
			<s:VGroup width="100%">
				<LabelWithWordWrap text="(4)Impute the missing data"/>
				<s:Button id="imputeMD" label="Impute Missing Data"
						  buttonDown="imputing_buttonDownHandler(event)"/>
			</s:VGroup>
			
			<s:Spacer height="{padding}"/>
			
			<s:VGroup>
				<s:HGroup>
					<s:CheckBox id="kMeansCheckbox"/> 
					<mx:LinkButton label="K Means Clustering"
								   click="kmeanslinkButton_clickHandler(event)"/>
					
				</s:HGroup>
				
				<s:HGroup>
					<s:CheckBox id="hClusteringCheckbox"/> 
					<mx:LinkButton label="Hierarchical Clustering"/>
					
				</s:HGroup>
				<LabelWithWordWrap text="Assign variable names and check Attributes KMeans Clustering"/>
				<mx:TextArea id="clusterTA" width="50%" height="25%" wordWrap="false"/>
				
			</s:VGroup>
			
			<s:Spacer height="{padding}"/>
			
			
			<s:HGroup>
				<s:CheckBox id="intermediateResultCB" label="Verbose"
							toolTip="Show intermediate results from R"/>
				<s:CheckBox id="warningCB" label="Warnings" toolTip="Show warnings from R"/>
			</s:HGroup>
			
			<s:Spacer height="{padding}"/>
			
		</s:VGroup>
	</s:HGroup>	
	
	
	<fx:Script>
		<![CDATA[
			import mx.collections.ArrayCollection;
			import mx.controls.Alert;
			import mx.events.FlexEvent;
			import mx.managers.PopUpManager;
			import mx.rpc.AsyncToken;
			import mx.rpc.events.FaultEvent;
			import mx.rpc.events.ResultEvent;
			
			import spark.layouts.HorizontalLayout;
			
			import weave.Weave;
			import weave.api.WeaveAPI;
			import weave.api.linkBindableProperty;
			import weave.api.newLinkableChild;
			import weave.api.registerLinkableChild;
			import weave.api.reportError;
			import weave.api.core.ILinkableHashMap;
			import weave.api.data.IAttributeColumn;
			import weave.api.data.IQualifiedKey;
			import weave.api.ui.IVisTool;
			import weave.core.LinkableHashMap;
			import weave.core.LinkableString;
			import weave.data.DataSources.CSVDataSource;
			import weave.data.KeySets.KeySet;
			import weave.services.WeaveRServlet;
			import weave.services.addAsyncResponder;
			import weave.services.beans.RResult;
			import weave.utils.ColumnUtils;
			import weave.utils.VectorUtils;
			import weave.visualization.tools.DataTableTool;
			import weave.visualization.tools.SimpleVisTool;
			
			WeaveAPI.registerImplementation(IVisTool, SchafersMissingDataTool, "Schafers Missing Data Imputation Tool");
			
			
			private const padding:int = 5;
			
			private static function get selection():KeySet
			{
				return Weave.root.getObject(Weave.DEFAULT_SELECTION_KEYSET) as KeySet;
			}
			
			public const variables:LinkableHashMap = registerLinkableChild(this, new LinkableHashMap(IAttributeColumn));
			private var Rservice:WeaveRServlet = new WeaveRServlet(Weave.properties.rServiceURL.value);
			public const inputTALinkable:LinkableString = newLinkableChild(this, LinkableString);
			public const outputTALinkable:LinkableString = newLinkableChild(this, LinkableString);
			public const assignTALinkable:LinkableString = newLinkableChild(this, LinkableString);
			
			
			override protected function constructor():void
			{
				super.constructor();				
				var columns:Array = SimpleVisTool.getDefaultColumnsOfMostCommonKeyType();
				for (var i:int = 0; i < columns.length; i++)
					variables.requestObjectCopy(null, columns[i]);
			}
			
			override protected function childrenCreated():void
			{
				super.childrenCreated();
				/* linkBindableProperty(outputTALinkable,outputTA,"text"); */
				linkBindableProperty(assignTALinkable,assignTA,"text");
			}
			
			/**
			 * @return A multi-dimensional Array like [keys, [data1, data2, ...]] where keys implement IQualifiedKey
			 */
			private function joinColumns(columns:Array):Array
			{
				var keys:Array = selection.keys.length > 0 ? selection.keys : null;
				//make dataype Null, so that columns will be sent as exact dataype to R
				//if mentioned as String or NUmber ,will convert all columns to String or Number .
				var result:Array = ColumnUtils.joinColumns(columns,null, true, keys);
				return [result.shift(),result];
			}
			
			[Bindable]
			private var finalCollection:ArrayCollection = new ArrayCollection();
			
			private var headings:Array = new Array();
			//private var currentDataGrid:DataGrid = null;
			private var dataTB:DataTableTool ;
			
			
			private function handleRunScriptResult(event:ResultEvent, token:Object = null):void
			{
				var finalImputedRColumns:Array = new Array();
				var missingCountInEachColumn:Array = new Array();
				
				
				//Object to stored returned result - Which is array of object{name: , value: }
				var Robj:Array = event.result as Array;				
				
				if (Robj == null)
				{
					reportError("R Servlet did not return an Array of results as expected.");
					return;
				}
				
				//Collecting all RResult Objects into an Array 
				var RresultArray:Array = new Array();
				
				//collecting Objects of type RResult(Should Match result object from Java side)
				for (var i:int = 0; i < (event.result).length; i++)
				{
					if (Robj[i] == null)
					{
						trace("WARNING! R Service returned null in results array at index "+i);
						continue;
					}
					var rResult:RResult = new RResult(Robj[i]);
					RresultArray.push(rResult);						
				}	
				
				/* This is the final array added as a CSVDataSource having structure
				[
				["k","x","y","z"]
				["k1",1,2,3]
				["k2",3,4,6]
				["k3",2,4,56]
				] */
				
				/* Creates the final array, stated above, for CSVDatasource
				Keys used from token
				We use the localName property because otherwise it casts the same key for all the values and thus 
				each key is not unique
				*/
				
				//To make availabe for Weave -Mapping with key returned from Token
				var keys:Array = token as Array;
				
				missingCountInEachColumn = [];
				finalImputedRColumns = []; 
				
				if (RresultArray.length == 1)//if only one element inthe returned R obj then only report missing data counts
				{
					missingCountInEachColumn = RresultArray[0].value;
					for(var f:int = 0 ; f < missingCountInEachColumn.length ; f++)
					{
						if(missingCountInEachColumn[f] != 0)
						{
							Alert.show("Your data has missing values.\n Impute Data using the 'Impute Missing Data' button");
							break;
						}
					} 
				}
					
					
				else
				{
					missingCountInEachColumn = RresultArray[0].value;//missing data count in each COLUMN
					finalImputedRColumns = RresultArray[1].value;
					for (var c:int = 0; c < keys.length; c++)					
					{
						finalImputedRColumns[c].unshift(missingCountInEachRecord[c]);
						finalImputedRColumns[c].unshift(keys[c].localName);
					}
					
					finalImputedRColumns.unshift(columnNames);
					
					
					/**
					 * Creating  new CSVDatacource
					 **/
					
					//Give it a unique name incase we need to store the columns from multiple imputations
					var name:String = Weave.root.generateUniqueName("ImputedColumns");
					var imputedCsvDataSource:CSVDataSource = Weave.root.requestObject( name,CSVDataSource,false);
					imputedCsvDataSource.setCSVData(finalImputedRColumns);
					imputedCsvDataSource.keyType.value = (keys[0] as IQualifiedKey).keyType;
					imputedCsvDataSource.keyColName.value = "Key";
					
					
					
					/**
					 * Creating a new Datatable tool
					 **/
					
					//checks if a datatable already exists, if not creates one
					var dataTBName:String = Weave.root.getName(this) + "DataTableTool";
					if(Weave.root.getObject(dataTBName)==null)
					{
						dataTB = Weave.root.requestObject(dataTBName,DataTableTool,false);
						dataTB.columns.removeAllObjects();
						
					}
					
					//dataTB.columns.setSessionState(variables.getSessionState(),false);
					//helps us get the original columns with the missing data
					var variableObjects:Array = variables.getObjects();
					for(var h:int = 0; h < variableObjects.length; h++)
					{
						dataTB.columns.requestObjectCopy(null,variableObjects[h]);
					} 
					
					
					//this loop includes the imputed columns in the datatable, the imputedcolumns being taken from
					//the imputedCsvDatasource
					var csvColNames:Array = imputedCsvDataSource.getColumnNames();
					for (var idx:int = 0; idx < csvColNames.length ; idx++)
					{
						imputedCsvDataSource.putColumnInHashMap(csvColNames[idx],dataTB.columns as ILinkableHashMap);
					}   
					
				}	
				
			}
			
			/* 	
			private function handleClusterScriptResult(event:ResultEvent, token:Object = null):void
			{
			//Object to stored returned result - Which is array of object{name: , value: }
			var Robj:Array = event.result as Array;
			trace('Robj:',ObjectUtil.toString(Robj));
			if (Robj == null)
			{
			reportError("R Servlet did not return an Array of results as expected.");
			return;
			}
			
			
			var RresultArray:Array = new Array();
			//collecting Objects of type RResult(Should Match result object from Java side)
			for (var i:int = 0; i < (event.result).length; i++)
			{
			if (Robj[i] == null)
			{
			trace("WARNING! R Service returned null in results array at index "+i);
			continue;
			}
			var rResult:RResult = new RResult(Robj[i]);
			RresultArray.push(rResult);				
			}
			
			
			
			//To make availabe for Weave -Mapping with key returned from Token
			var keys:Array = token as Array;
			
			//Objects "(object{name: , value:}" are mapped whose value length that equals Keys length
			for (var p:int = 0;p < RresultArray.length; p++)
			{
			
			if(RresultArray[p].value is Array){
			if(keys){
			if ((RresultArray[p].value).length == keys.length){
			if (RresultArray[p].value[0] is String)	{
			var testStringColumn:StringColumn = Weave.root.requestObject(RresultArray[p].name, StringColumn, false);
			var keyVec:Vector.<IQualifiedKey> = new Vector.<IQualifiedKey>();
			var dataVec:Vector.<String> = new Vector.<String>();
			VectorUtils.copy(keys, keyVec);
			VectorUtils.copy(Robj[p].value, dataVec);
			testStringColumn.setRecords(keyVec, dataVec);
			if (keys.length > 0)
			testStringColumn.weave_internal::metadata.@keyType = (keys[0] as IQualifiedKey).keyType;
			testStringColumn.weave_internal::metadata.@name = RresultArray[p].name;
			}
			else{
			var table:Array = [];
			for (var k:int = 0; k < keys.length; k++)
			table.push([ (keys[k] as IQualifiedKey).localName, Robj[p].value[k] ]);
			
			//testColumn are named after respective Objects Name (i.e) object{name: , value:}
			var testColumn:CSVColumn = Weave.root.requestObject(RresultArray[p].name, CSVColumn, false);
			testColumn.keyType.value = keys.length > 0 ? (keys[0] as IQualifiedKey).keyType : null;
			testColumn.numericMode.value = true;
			testColumn.csvData.value = WeaveAPI.CSVParser.createCSV(table);
			testColumn.title.value = RresultArray[p].name;
			}
			}
			}						
			}										
			}
			}
			
			*/			
			private function handleRunScriptFault(event:FaultEvent, token:Object = null):void
			{
				trace(["fault", token, event.message].join('\n'));
				reportError(event);
			}
			
			private var assignToBeValues:Array = new Array();
			private var assignNames: Array = new Array();
			private var columnNames:Array = new Array();//stores the names of the columns (an array of strings)
			private var missingCountInEachRecord:Array = new Array();//need to display in a column in the final datatable
			
			
			protected function imputing_buttonDownHandler(event:FlexEvent):void
			{
				
				var result:Array = new Array();
				var joinedColumnQKeys:Array; //Columns from Joined columns Method
				var joinedColumns:Array;
				
				var selectedColumns:Array = variables.getObjects(); //Columns from ColumnListComponent 
				
				var attributeColumns:Array = new Array();
				columnNames = [];//clear this array preparing it for every new imputation
				//Use as Attribute column as joinColumns takes members of IAttributeColumn
				for(var i:int = 0; i<selectedColumns.length; i++)
				{
					attributeColumns[i] = selectedColumns[i] as IAttributeColumn;
					columnNames[i] = ColumnUtils.getTitle(attributeColumns[i]);
					columnNames[i] = "Imputed"+columnNames[i];
				}
				
				
				columnNames.unshift("NoOfMissingValues");
				columnNames.unshift("Key");
				//joinColumns Called only When columns are added to ColumnListComponent
				
				if(selectedColumns.length >0)
				{					
					// get records for keys common to all columns 
					result = joinColumns(attributeColumns);
					joinedColumnQKeys = result[0];
					joinedColumns = result[1];
					
				}
				
				//getting the number of missing values in EACH RECORD
				var rowNumber:Array = joinedColumns[0];
				var missingCount:int = 0;
				for(var h:int = 0; h < rowNumber.length; h++)
				{
					for(var g:int = 0; g < joinedColumns.length;g++){
						var tempArray:Array = joinedColumns[g];
						if(tempArray[h] == undefined){
							missingCount++;
						}
					}
					
					missingCountInEachRecord.push(missingCount);
					missingCount = 0;
				}
				
				
				
				assignToBeValues = joinedColumns;
				
				//variable names for the columns to be used in R
				var RscriptAssignNames:String = assignTA.text;//as complete string
				
				//broken into individual variable names
				assignNames = VectorUtils.flatten(WeaveAPI.CSVParser.parseCSV(assignTA.text));
				
				
				if(assignNames.length > selectedColumns.length)
				{
					Alert.show("Please delete "+ (assignNames.length - selectedColumns.length) + "variable(s)");
				}
				
				if(selectedColumns.length > assignNames.length)
				{
					Alert.show("Please enter "+ (selectedColumns.length - assignNames.length) + "variable(s)");
				}
				
				
				
				headings = assignNames;//to get the headings for the missing data columns
				
				
				outputNames = [];//empty this for every new communication with R
				
				//Query is created from runScript with same signature from Jave side
				var showIntermediateResults:Boolean = intermediateResultCB.selected;
				var showWarnings:Boolean = warningCB.selected;
				
				//var query:AsyncToken = Rservice.runScript([],assignNames, assignToBeValues, outputNames, script,"", showIntermediateResults,showWarnings,false);
				//Script is built in on the java side in RserviceUsingRserve
				var imputationQuery:AsyncToken;
				
				if (event.currentTarget == checkforNA)
				{
					outputNames.push("pre$nmis");
					imputationQuery = Rservice.handlingMissingData(assignNames,assignToBeValues,outputNames,false,false,false);
				}
					
				else
				{
					outputNames.push("pre$nmis");
					outputNames.push("imputed");
					imputationQuery = Rservice.handlingMissingData(assignNames,assignToBeValues,outputNames,false,false,true);
				}
				
				
				addAsyncResponder(imputationQuery, handleRunScriptResult, handleRunScriptFault, joinedColumnQKeys);
				
			}
			
			private var focusedTA:TextArea = null; 
			private var outputNames:Array = new Array();
			private var clusterInputValues:Array = new Array();
			
			
			/* 		
			protected function clusterButton_clickHandler(event:MouseEvent):void
			
			{
			var result:Array = new Array();
			var joinedColumnQKeys:Array; //Columns from Joined columns Method
			var joinedColumns:Array;
			
			//TO BE DONE
			//Determine choice of columns for clustering, (1)Original (2) Imputed  (3)Both
			//var selectedColumns:Array = dataTB.columns.getObjects(); imputed data used for clustering
			var selectedColumns:Array = variables.getObjects(); //Columns from ColumnListComponent
			
			var attributeColumns:Array = new Array();
			columnNames = [];
			//Use as Attribute column as joinColumns takes members of IAttributeColumn
			var idx:int = 0;
			for(var i:int = 0; i<selectedColumns.length; i++)
			{
			var attrCol:IAttributeColumn = selectedColumns[i] as IAttributeColumn;
			if((ColumnUtils.getTitle(attrCol) == "Key") || (ColumnUtils.getTitle(attrCol) == "NoOfMissingR")){
			
			}
			else{
			attributeColumns[idx] = attrCol;
			idx++;
			} 
			
			
			}
			//joinColumns Called only When columns are added to ColumnListComponent
			
			if(selectedColumns.length >0)
			{					
			// get records for keys common to all columns 
			result = joinColumns(attributeColumns);
			joinedColumnQKeys = result[0];
			joinedColumns = result[1];
			
			}
			
			clusterInputValues = joinedColumns;
			
			//variable names for the columns to be used in R
			var RscriptAssignNames:String = clusterTA.text;//as complete string
			
			//broken into individual variable names
			assignNames = VectorUtils.flatten(WeaveAPI.CSVParser.parseCSV(clusterTA.text));				
			
			
			var showWarnings:Boolean = warningCB.selected;
			
			
			
			//var clusterQuery:AsyncToken = Rservice.KMeansClustering(assignNames, clusterInputValues,false, Number(clusterNumber.text),Number(iterationNumber.text));
			
			addAsyncResponder(clusterQuery, handleClusterScriptResult, handleRunScriptFault, joinedColumnQKeys);
			
			} */
			
			protected function kmeanslinkButton_clickHandler(event:MouseEvent):void
			{
				// TODO Auto-generated method stub
				var kMeansPopupEditor:KMeansClusteringEditor = new KMeansClusteringEditor();
				mx.managers.PopUpManager.addPopUp(kMeansPopupEditor,this, false);
			}
			
		]]>
	</fx:Script>
	
</DraggablePanel>
