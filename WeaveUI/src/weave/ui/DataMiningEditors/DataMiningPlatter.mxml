<?xml version="1.0" encoding="utf-8"?>
<!--
/*
Weave (Web-based Analysis and Visualization Environment)
Copyright (C) 2008-2011 University of Massachusetts Lowell

This file is a part of Weave.

Weave is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License, Version 3,
as published by the Free Software Foundation.

Weave is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Weave.  If not, see <http://www.gnu.org/licenses/>.
*/

/*Editor to specify parameters for all the  data mining algorithms*/
@spurushe-->



<DraggablePanel xmlns="weave.ui.*" xmlns:mx="http://www.adobe.com/2006/mxml" 
				horizontalScrollPolicy="off" verticalScrollPolicy="off"
				title="Data Mining Algorithm Toolbox"
				
				backgroundColor="0x87CEFF" width="300" height="400"
				layout="horizontal"
				autoLayout="true"
				implements="weave.api.ui.IVisTool" creationComplete="init();" xmlns:DataMiningEditors="weave.ui.DataMiningEditors.*" xmlns:s="library://ns.adobe.com/flex/spark"
				>
	
	<mx:Script>
		<![CDATA[
			import mx.binding.utils.BindingUtils;
			import mx.collections.ArrayCollection;
			import mx.containers.VBox;
			import mx.controls.Spacer;
			import mx.core.UIComponent;
			import mx.events.CollectionEvent;
			import mx.events.ListEvent;
			import mx.utils.ObjectUtil;
			
			import weave.Weave;
			import weave.api.WeaveAPI;
			import weave.api.core.ICallbackCollection;
			import weave.api.core.ILinkableHashMap;
			import weave.api.data.IAttributeColumn;
			import weave.api.data.IQualifiedKey;
			import weave.api.disposeObjects;
			import weave.api.newDisposableChild;
			import weave.api.registerLinkableChild;
			import weave.core.CallbackCollection;
			import weave.core.LinkableHashMap;
			import weave.core.UIUtils;
			import weave.data.AttributeColumns.NumberColumn;
			import weave.data.KeySets.KeySet;
			import weave.utils.ColumnUtils;
			import weave.utils.ResultUtils;
			
			[Bindable]
			private var selectedAlgorithmList:Array = new Array();
			private	var parameterInputPanel:DMiningParameterPanel;
			private var _inputVariables:ILinkableHashMap = null;
			private var finalColumnsGroup:ICallbackCollection; // linkable object used to group norm columns and check busy status
			public var subsetFinalColumns:Array = new Array();
			public var selectedRecords:Array = new Array();//when a subset selected from a visualization is the input for Dm algos
			public var subsetSelectedOn:Boolean = false;// if this tool is used for ubset selection, will be changed to true
			public var latestColumnKeys:Array = new Array();
			public var finalColumns:Array = new Array();
			
			
			private static var platterInstance : DataMiningPlatter = null;
			private var currentDMObject:DataMiningAlgorithmObject;
			private var collectionOfDataMinigObjects:Dictionary = new Dictionary();// collects all the data mining objects and then sends them to the DataminingChannelToR for comuptation in R
			
			[Bindable]
			public function get inputVariables():ILinkableHashMap
			{
				return _inputVariables;
			}

			public function set inputVariables(value:ILinkableHashMap):void
			{
				/*Setting the input hashmap everytime
				the tool can be openened for loading in columns or for running of subsets selected
				in each case clear the hashmap previously used*/
				//(inputVariables as LinkableHashMap).dispose();
				if(_inputVariables){
					(_inputVariables as LinkableHashMap).dispose();
				}
					
				_inputVariables = value;
				if(value != null)
					(_inputVariables as LinkableHashMap).addGroupedCallback(this, preprocessingColumns);
				
			}

			public static function getPlatterInstance():DataMiningPlatter 
			{
				if(platterInstance == null) platterInstance = new DataMiningPlatter();
				 return platterInstance;
			}
			
			private function init():void
			{
				algoListFiller.dispatchEvent(new CollectionEvent(CollectionEvent.COLLECTION_CHANGE));
				trace("arrayCollection dispatched event"); 
			}
			
			override protected function constructor():void
			{
				super.constructor();
				/* var columns:Array = SimpleVisTool.getDefaultColumnsOfMostCommonKeyType();
				for (var i:int = 0; i < columns.length; i++)
				inputColumns.requestObjectCopy(null, columns[i]); */
			}
			
			override protected function childrenCreated():void
			{
				super.childrenCreated();
				preprocessingColumns();
			}
			
			// we need only numerical columns for clustering
			private function preprocessingColumns():void
			{
				var colObjects:Array = inputVariables.getObjects(IAttributeColumn);
				var attributeColumns :Array = new Array();
				for (var i:int = 0; i < colObjects.length; i++)
				{
					var col:IAttributeColumn = colObjects[i] as IAttributeColumn;
					var datatype:String = ColumnUtils.getDataType(col);
					if(datatype == "number")
					{
						attributeColumns.push(col);
					}
				}
				
				if(subsetSelectedOn == true)
				{
					handleColumnsForSubsetSelection(attributeColumns);//when user wants to run data mining algorithms on selected subsets 
					subsetSelectedOn = false;
				}
				
				else
				{
					handleRegularColumns(attributeColumns);//when user loads in a dataset or selects entire columns
				}
				
			}
			
			//handles columns when this tool is run on columns loaded through columns list component
			private function handleRegularColumns(attributeColumns:Array):void
			{
				var joinedColumns:Array = ResultUtils.joinColumns(attributeColumns);
				latestColumnKeys = joinedColumns[0];
				finalColumns = joinedColumns[1]; 
			}
			
			//handles columns when this tool is run on subset selection
			private function handleColumnsForSubsetSelection(attributeColumns:Array):void
			{
				var tempColumns:Array = new Array();
				for(var h :int = 0; h < attributeColumns.length; h++)
				{
					tempColumns[h] = new Array();
				}
				
				for(var s:int = 0; s < attributeColumns.length; s++)
				{
					var testCol:IAttributeColumn = attributeColumns[s];
					for(var f:int = 0; f < selectedRecords.length; f++)
					{
						var key:IQualifiedKey = selectedRecords[f] as IQualifiedKey;
						tempColumns[s].push(testCol.getValueFromKey(key,Number));
					}
				}
				
				//converting subsetcollection into columns
				disposeObjects(finalColumnsGroup);
				finalColumnsGroup = newDisposableChild(this, CallbackCollection);
				for (var j:int = 0 ; j < tempColumns.length; j++)
				{
					var pickUpColumn:IAttributeColumn = (attributeColumns[j] as IAttributeColumn);
					var testcol:NumberColumn = ResultUtils.resultAsNumberColumn(selectedRecords,tempColumns[j],(ColumnUtils.getTitle(pickUpColumn)+"norm"));
					subsetFinalColumns.push(testcol);
					registerLinkableChild(finalColumnsGroup, testcol);
				}
				
				finalColumnsGroup.addImmediateCallback(this, checkifColumnsFilled);
				
			} 
			
			private function checkifColumnsFilled():void
			{
				if (WeaveAPI.SessionManager.linkableObjectIsBusy(finalColumnsGroup))//do the next chunk of code only after columns have been generated and collected
					return;
				
				 var joinedColumns:Array = ResultUtils.joinColumns(subsetFinalColumns);
				latestColumnKeys = joinedColumns[0];
				finalColumns = joinedColumns[1]; 
				
			}
			
			private function algoListFiller_collectionChange(event:CollectionEvent):void
			{
				try
				{
					trace("status changed");
					selectedAlgorithmList = listOfAlgo.filter(returnIfSelected);
					trace(selectedAlgorithmList);
					selectedDisplayStatus.text = String(selectedAlgorithmList.length) + " algorithm(s) selected";
					
				} catch(err:Error){
					//do nothing
				}
			}
			
			private function returnIfSelected(obj:DataMiningAlgorithmObject, idx:int, listOfAlgo:Array):Boolean
			{
				var tempCheck:Boolean = obj.isSelectedInAlgorithmList;
				trace("selected" + obj.label);
				return tempCheck;
				
			}
			
			//this constructs the respective UI components depending on which algorithm is selected
		    public function constructParameterInput(data:DataMiningAlgorithmObject):void
			{
					var cb:ControlBar = new ControlBar();
				//check if already exists; creating only one instance of the platter
				if(parameterInputPanel == null) 
				{
					parameterInputPanel = new DMiningParameterPanel;
					parameterInputPanel.width = 0.35 * originalBox.width; 
					parameterInputPanel.height = 0.8 * originalBox.height;
					var saveB:Button = new Button(); 
					saveB.label = "Save"; 
					saveB.addEventListener(MouseEvent.CLICK, savingParameters);
					cb.addChild(saveB);
				}
				originalBox.addChild(parameterInputPanel);
				
				if(data.isSelectedInAlgorithmList == false)
				{
					parameterInputPanel.removeAllChildren();
					
				}
				
				//clear the panel before any new dispay of input UI
				if(data.isSelectedInAlgorithmList == true)
				{
					parameterInputPanel.removeAllChildren();
					var objectsReturned:Array = parameterInputPanel.generateUIComponents(data);//returns an array [uicomponents, dmObject]
					
					for( var r:int = 0; r < objectsReturned.length; r++)
					{
						if(objectsReturned[r] is VBox)
						var uiComponentList:VBox = objectsReturned[r];
						if(objectsReturned[r] is DataMiningAlgorithmObject)
				   	    currentDMObject = objectsReturned[r] as DataMiningAlgorithmObject;
					}
					
					
					parameterInputPanel.addChild(uiComponentList);
					parameterInputPanel.addChild(cb);//always keep the Save button
					
				}
			}	
			
			/* -----------------------------------------------BUTTON CLICK HANDLERS-------------------------------------------------------------------------- */		
			//saves the parameters for each dataminingalgorithm object
			private function savingParameters(event:Event):void
			{
				for(var g :int = 0; g < currentDMObject.parameters.length; g++)
				{
					if(currentDMObject.parameters[g] is NumberInputComponent)
					{
						var tempComponentType:NumberInputComponent = currentDMObject.parameters[g];
						currentDMObject.parameterMapping[tempComponentType.identifier] = Number(tempComponentType.numberInput.text);
						
					}
					
					if(currentDMObject.parameters[g] is ChoiceInputComponent)
					{
						var tempComponentType2:ChoiceInputComponent = currentDMObject.parameters[g];
						currentDMObject.parameterMapping[tempComponentType2.identifier] = tempComponentType2.choiceBox.selectedLabel;
						
					}
				}
				
				//finally
				if(!collectionOfDataMinigObjects.hasOwnProperty(currentDMObject.label))
					{
						collectionOfDataMinigObjects[currentDMObject.label] = currentDMObject;
					}
			}
			
			/*------------------------------------------------SENDING DATAMING OBJECTS TO R---------------------------------------------------------------------*/
			
			protected function sendToRButton_clickHandler(event:MouseEvent):void
			{
				 var Rchannel:DataMiningChannelToR = new DataMiningChannelToR(collectionOfDataMinigObjects,finalColumns,latestColumnKeys);
			}
			
		]]>
	</mx:Script>
	
	<mx:Array id="listOfAlgo">
		<DataMiningEditors:DataMiningAlgorithmObject label ="KMeans Clustering" isSelectedInAlgorithmList="false"/>
		<DataMiningEditors:DataMiningAlgorithmObject label ="Fuzzy KMeans Clustering" isSelectedInAlgorithmList="false"/>
		<DataMiningEditors:DataMiningAlgorithmObject label="Partition Around Medoids Clustering" isSelectedInAlgorithmList="false"/>
		<DataMiningEditors:DataMiningAlgorithmObject label ="Hierarchical Clustering" isSelectedInAlgorithmList="false"/>
	</mx:Array>
	
	<mx:ArrayCollection id="algoListFiller" 
						source="{listOfAlgo}" 
						collectionChange="algoListFiller_collectionChange(event);"/>
	<mx:VBox width="100%" height="100%">
	<mx:HBox id="originalBox" width="100%" height="95%">
		<!--1-->
		<ColumnListComponent width="20%" height="80%" id="columns" hashMap="{inputVariables}"/>
		<!--2-->
			<mx:Panel width="20%" height="80%"
					  id="pan1" paddingBottom="10" paddingLeft="10" paddingRight="10" paddingTop="10"
					  title="Choose the data mining algorithms"
					  styleName="opaquePanel">
				<mx:List id="dmAlgoList" width="100%" height="100%" dataProvider="{algoListFiller}"
						 alternatingItemColors="[#EEEEEE, white]" 
						 toolTip="Select the checkbox to enter parameter input">
					
					<mx:itemRenderer>
						<mx:Component>
								<mx:CheckBox  selectedField ="isSelectedInAlgorithmList"
											 change="cb_changeHandler(event)">
								<mx:Script>
									<![CDATA[
										
										private function cb_changeHandler(event:Event):void
										{
											(data as DataMiningAlgorithmObject).isSelectedInAlgorithmList = !(data as DataMiningAlgorithmObject).isSelectedInAlgorithmList;
											outerDocument.constructParameterInput(data as DataMiningAlgorithmObject);
										}
									]]>
								</mx:Script>
								</mx:CheckBox>
						</mx:Component>
					</mx:itemRenderer>
				</mx:List>	
			<mx:ControlBar horizontalAlign="right">
				<mx:Label id="selectedDisplayStatus"/>
			</mx:ControlBar>
   			</mx:Panel>	
	
		
		<!--3-->
			<mx:Panel width="25%" height="80%" title="Algorithm Cart" fontWeight="bold" styleName="opaquePanel"
					  paddingBottom="10" paddingLeft="10" paddingRight="10" paddingTop="10">
				<mx:List width = "100%" height="100%" id="secondList" dataProvider="{selectedAlgorithmList}"
						  alternatingItemColors="[#FFA2FF, white]" toolTip="Click on algorithm to view parameter input">
				</mx:List>
				<mx:ControlBar horizontalAlign="right">
					<mx:Button label="Save List"/>
					<mx:Button label="Import List"/>
				</mx:ControlBar>
			<!--mx:TextArea  width = "100%" height="100%" id="displayList" text="" color="0x635BAA" fontWeight="bold">
				
			</mx:TextArea-->
		  </mx:Panel>
		
</mx:HBox>
	
	<mx:HBox width="100%" height="5%">
		
	<s:Spacer height="10" width="90%"/>
   <mx:Button id="sendToRButton" height="20" label="Run" click="sendToRButton_clickHandler(event)"/>
	</mx:HBox>
</mx:VBox>
</DraggablePanel> 

