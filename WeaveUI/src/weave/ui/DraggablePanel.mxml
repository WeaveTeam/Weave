<?xml version="1.0" encoding="utf-8"?>
<!--
/*
Weave (Web-based Analysis and Visualization Environment)
Copyright (C) 2008-2011 University of Massachusetts Lowell

This file is a part of Weave.

Weave is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License, Version 3,
as published by the Free Software Foundation.

Weave is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Weave.  If not, see <http://www.gnu.org/licenses/>.
*/
-->

<mx:TitleWindow xmlns:mx="http://www.adobe.com/2006/mxml"
				xmlns:sessioning="weave.core.*"
				xmlns="weave.ui.*"
				addedToStage="handleAddedToStage(event)"
				removedFromStage="handleRemovedFromStage(event)"
				preinitialize="preinitialize()"
				rollOver="handleMouseRollOver(event)"
				rollOut="handleMouseRollOut(event)"
				horizontalScrollPolicy="off"
				verticalScrollPolicy="off"
				creationPolicy="all"
				resize="handleResize(event)"
				creationComplete="handleCreationComplete()"
				layout="absolute"
				close="handleCloseButtonClick()"
				
				closeButtonUpSkin="@Embed(source='/weave/resources/images/cancel.png')"
				closeButtonOverSkin="@Embed(source='/weave/resources/images/cancel.png')"
				closeButtonDownSkin="@Embed(source='/weave/resources/images/cancel.png')"
				
				titleStyleName="weave-panel-title-style"
				styleName="weave-panel-style"
				
				implements="weave.api.core.IDisposableObject, weave.api.core.ILinkableObject"
				>
	<mx:Script>
		<![CDATA[
			import mx.containers.Canvas;
			import mx.containers.TitleWindow;
			import mx.controls.Alert;
			import mx.controls.Button;
			import mx.controls.ComboBox;
			import mx.controls.Image;
			import mx.core.SpriteAsset;
			import mx.core.UIComponent;
			import mx.events.CloseEvent;
			import mx.events.DragEvent;
			import mx.events.ResizeEvent;
			import mx.managers.ISystemManager;
			import mx.managers.PopUpManager;
			
			import weave.Weave;
			import weave.api.core.ILinkableHashMap;
			import weave.api.core.ILinkableObject;
			import weave.api.getCallbackCollection;
			import weave.api.getLinkableOwner;
			import weave.api.newDisposableChild;
			import weave.api.newLinkableChild;
			import weave.api.objectWasDisposed;
			import weave.api.registerDisposableChild;
			import weave.api.registerLinkableChild;
			import weave.api.reportError;
			import weave.api.ui.IObjectWithSelectableAttributes;
			import weave.compiler.StandardLib;
			import weave.core.ClassUtils;
			import weave.core.LinkableBoolean;
			import weave.core.LinkableFunction;
			import weave.core.LinkableNumber;
			import weave.core.LinkableString;
			import weave.core.StageUtils;
			import weave.core.UIUtils;
			import weave.ui.controlBars.VisTaskbar;
			import weave.utils.CustomCursorManager;
			import weave.utils.NumberUtils;
			
			public var debug:Boolean = false;
			
			/**
			 * panelX, panelY, panelWidth, panelHeight
			 * These are sessioned strings that can be either absolute coordinates or percentages.
			 */
			public const panelX:LinkableString      = registerLinkableChild(this, new LinkableString(null, NumberUtils.verifyNumberOrPercentage));
			public const panelY:LinkableString      = registerLinkableChild(this, new LinkableString(null, NumberUtils.verifyNumberOrPercentage));
			public const panelWidth:LinkableString  = registerLinkableChild(this, new LinkableString(null, NumberUtils.verifyNumberOrPercentage));
			public const panelHeight:LinkableString = registerLinkableChild(this, new LinkableString(null, NumberUtils.verifyNumberOrPercentage));
			
			public const maximized:LinkableBoolean = registerLinkableChild(this, new LinkableBoolean(false, verifyMaximized), handleMaximizedChange, true);
			public const minimized:LinkableBoolean = registerLinkableChild(this, new LinkableBoolean(false, verifyMinimized), handleMinimizedChange, true);
			public const zOrder:LinkableNumber = registerLinkableChild(this, new LinkableNumber(0, StandardLib.isDefined), handleZOrderChange, true);
			
			public const panelTitle:LinkableString = newLinkableChild(this, LinkableString, handlePanelTitleChange, true);
			
			public const enableMoveResize:LinkableBoolean = registerLinkableChild(this, new LinkableBoolean(true), panelNeedsUpdate, true);
			public const enableSubMenu:LinkableBoolean = registerLinkableChild(this, new LinkableBoolean(false));
			public const minimizable:LinkableBoolean = registerLinkableChild(this, new LinkableBoolean(true), panelNeedsUpdate, true);
			public const maximizable:LinkableBoolean = registerLinkableChild(this, new LinkableBoolean(true), panelNeedsUpdate, true);
			public const enableZOrder:LinkableBoolean = registerLinkableChild(this, new LinkableBoolean(true), panelNeedsUpdate, true);
			public const closeable:LinkableBoolean = registerLinkableChild(this, new LinkableBoolean(true), panelNeedsUpdate, true);
			public const enableBorders:LinkableBoolean = registerLinkableChild(this, new LinkableBoolean(true), panelNeedsUpdate, true);
			
			public const panelBorderColor:LinkableNumber = registerLinkableChild( this, new LinkableNumber(NaN), handleBorderColorChange, true);
			public const panelBackgroundColor:LinkableNumber = registerLinkableChild( this, new LinkableNumber(NaN), handleBackgroundColorChange, true);
			public const buttonRadius:LinkableNumber = registerLinkableChild(this, new LinkableNumber(3, isFinite), panelNeedsUpdate, true);
			public const panelStyleList:LinkableString = newLinkableChild(this, LinkableString, handlePanelStyleListChange);
			
			private function verifyMinimized(value:Boolean):Boolean { return !minimizable || minimizable.value || !value; }
			private function verifyMaximized(value:Boolean):Boolean { return !maximizable || maximizable.value || !value; }
			
			public const userControlButton:Button = new Button();
			protected const subMenuButton:Button = new Button();
			protected const attributeButton:Button = new Button();
			protected const minimizeButton:Button = new Button();
			protected const maximizeButton:Button = new Button();
			protected const closePanelButton:Button = new Button();
			protected const zOrderButton:Button = new Button();
			
			private const _dragCanvas:Canvas = new Canvas();
			
			/**
			 * Set this to false to avoid creating a busy indicator. Must be set before creationComplete.
			 */
			public var showBusyIndicator:Boolean = true;
			
			private var busyIndicator:BusyIndicator;
			
			private var _moveImage:Image = new Image();

			private var _constructorCalled:Boolean = false; // true when constructor has been called
			private const panelTitleFunction:LinkableFunction = registerDisposableChild(this, new LinkableFunction(null, true, true)); // this is used in handlePanelTitleChange()
			
			[Bindable] public var sessionPanelCoordsAsPercentages:Boolean = true;
			
			private var _overriddenStyles:Object = new Object();
			private var draggablePanelCursorID:int = -1;
			
			private var _escapeKeyClosesPanel:Boolean = false;
			private var _initialTitleBarMouseDownPoint:Point = new Point(0,0);
			
			private var _rightSideResize:Boolean = false;
			private var _leftSideResize:Boolean = false;
			private var _topSideResize:Boolean = false;
			private var _bottomResize:Boolean = false;
			private var _resizing:Boolean = false;
			private var _dragging:Boolean = false;
			
			private var _enableMoveResize:Boolean = false; // used internally to remember whether or not the panel is actually moveable
			
			private var _rightSideBeforeLeftResize:int = 0;
			private var _bottomSideBeforeTopResize:int = 0;
			
			private var _mouseRolledOver:Boolean = false;
			private var _controlPanel:ControlPanel = null;
			private var buttonSize:int = 17;
			private var buttonOffsetFromSide:int = 5;
			private var spaceBetweenButtons:Number = 2;
			private var _titleBarButtonBackgroundColor:uint = 0xD0D0D0;
			private var _titleBarButtonSelectedColor:uint   = 0xFFFF80;
			private var minimizedComponentVersion:MinimizedComponent = null;
			public const subMenu:SubMenu = new SubMenu(subMenuButton);
			protected const zOrderSubMenu:SubMenu = new SubMenu(zOrderButton);
			
			public function get controlPanel():ControlPanel { return _controlPanel; }

			/**
			 *  This method is called when a UIComponent is constructed,
			 *  and again whenever the ResourceManager dispatches
			 *  a <code>"change"</code> Event to indicate
			 *  that the localized resources have changed in some way.
			 */
			override protected function resourcesChanged():void
			{
				super.resourcesChanged();
				if (!_constructorCalled) // avoid calling constructor twice
				{
					_constructorCalled = true;
					reposition();
					constructor();
				}
			}
			
			/**
			 * A constructor cannot be defined in MXML.
			 * This function gets called as a result of calling the super class's constructor.
			 * Classes that extend DraggablePanel can override this and call super.constructor().
			 * Any code that should execute in the constructor can be put into this function.
			 * This function should not be called directly.
			 */
			protected function constructor():void
			{
				// use capture phase on mouse down event because otherwise, if the panel is a popup,
				// drop-down menus will be hidden behind the window after we move the window to the front.
				addEventListener(MouseEvent.MOUSE_DOWN, handleMouseDown, true);
				
				panelX.addImmediateCallback(this, function():void { copyCoordinatesFromSessionedProperties(panelX); });
				panelY.addImmediateCallback(this, function():void { copyCoordinatesFromSessionedProperties(panelY); });
				panelWidth.addImmediateCallback(this, function():void { copyCoordinatesFromSessionedProperties(panelWidth); });
				panelHeight.addImmediateCallback(this, function():void { copyCoordinatesFromSessionedProperties(panelHeight); });
				
				getCallbackCollection(Weave.properties.panelTitleTextFormat).addGroupedCallback(this, handleTitleTextFormatChange, true);
				Weave.properties.dashboardMode.addGroupedCallback(this, panelNeedsUpdate);
				Weave.properties.enableToolControls.addGroupedCallback(this, updateButtons, true);
				getCallbackCollection(this).addGroupedCallback(this, updateButtonsIfSelectableAttributesChanged, true);
				getCallbackCollection(this).addGroupedCallback(this, evaluatePanelTitle);
				getCallbackCollection(Weave.root).addGroupedCallback(this, evaluatePanelTitle);
			}
			
			/**
			 * This function gets called when the preinitialize event is dispatched.
			 * Subclasses can override this method and call super.preinitialize().
			 */
			protected function preinitialize():void
			{
				// nothing here, just a placeholder
			}
			
			protected var createdChildren:Boolean = false;
			override protected function createChildren():void
			{
				if (createdChildren)
					return;
				
				super.createChildren();
				
				createdChildren = true;
				
				// These calls to setStyle fix the display bug where there is a ~200 px bottom margin and ~20 px right margin.
				UIUtils.pad(this, 0);
				
				setupControlButton(userControlButton, [_userControlIcon, _userControlIcon2, _userControlIcon], toggleControlPanel, TOOLTIP_CONTROLS);
				setupControlButton(subMenuButton, _subMenuIcon, null, TOOLTIP_SUBMENU);
				setupControlButton(attributeButton, _attributeIcon, handleAttributeButtonClick, TOOLTIP_ATTRIBUTES);
				setupControlButton(zOrderButton, [icon_zOrder, icon_zOrderReverse, icon_zOrder], null);
				setupControlButton(minimizeButton, _minimizeIcon, handleMinimizeButtonClick, TOOLTIP_MINIMIZE);
				setupControlButton(maximizeButton, _maximizeIcon, toggleMaximized, TOOLTIP_MAXIMIZE);
				setupControlButton(closePanelButton, [_closeIcon, _closeIconColor2, _closeIconColor], handleCloseButtonClick, TOOLTIP_CLOSE);
				
				zOrderSubMenu.menuItems.push(
					new SubMenuItem(lang('Reset'), function():void { zOrder.value = 0; }, null, function():Boolean { return zOrder.value != 0; }),
					new SubMenuItem(lang('Always above'), function():void { zOrder.value = 1; }, null, function():Boolean { return zOrder.value <= 0; }),
					new SubMenuItem(lang('Always below'), function():void { zOrder.value = -1; }, null, function():Boolean { return zOrder.value >= 0; })
				);

				/*
				closePanelButton.setStyle("textRollOverColor", 0xFFFFFF);
				closePanelButton.setStyle("textSelectedColor", 0xFFFFFF);
				
				closePanelButton.addEventListener(MouseEvent.ROLL_OVER, function(e:Event):void {
					// make the close button red with white text when rolled over
					closePanelButton.setStyle("fillColors", [0xFF0000,0xFF0000] );
				});
				closePanelButton.addEventListener(MouseEvent.ROLL_OUT,  function(e:Event):void {
					// make the close button gray with black text when rolled out (default)
					closePanelButton.setStyle("fillColors", [_titleBarButtonBackgroundColor,_titleBarButtonBackgroundColor] );
				});
				*/
				
				// try to find a ControlPanel
				for (var i:int = 0; i < numChildren; i++)
				{
					if (getChildAt(i) is ControlPanel)
					{
						_controlPanel = registerDisposableChild(this, getChildAt(i) as ControlPanel);
						removeChild(_controlPanel);
						break;
					}
				}
				
				if (!_controlPanel && WeaveAPI.EditorManager.getEditorClass(this))
				{
					_controlPanel = newDisposableChild(this, ControlPanel);
					var editor:UIComponent = WeaveAPI.EditorManager.getNewEditor(this) as UIComponent;
					addChild(_controlPanel);
					removeChild(_controlPanel);
					_controlPanel.tabNavigator.addChild(editor);
				}
				
				if (_controlPanel)
				{
					_controlPanel.title = ControlPanel.getControlPanelTitle(this);
					_controlPanel.enableSubMenu.value = true;
					_controlPanel.sessionEditorTarget = this;
				}
				
				var icon:Bitmap = new MoveIcon() as Bitmap;
				_moveImage.source = icon;
				_moveImage.x = resizeBorderThickness;
				_moveImage.y = resizeBorderThickness;
				_moveImage.width = icon.width;
				_moveImage.height = icon.height;
//				_moveImage.toolTip = "Drag this icon to move the panel.";
//				if (_controlPanel)
//					_moveImage.toolTip += "  Double-click to open the control panel.";
				_moveImage.scaleContent = false;
				_moveImage.alpha = 0.25;
				_moveImage.addEventListener(MouseEvent.MOUSE_DOWN, handleTitleBarMouseDown);
				_moveImage.doubleClickEnabled = true;
				_moveImage.addEventListener(MouseEvent.DOUBLE_CLICK, function(e:Event):void { toggleControlPanel(); });
				
				titleBar.doubleClickEnabled = true;
				titleBar.addEventListener(MouseEvent.MOUSE_DOWN, handleTitleBarMouseDown);
				titleBar.addEventListener(MouseEvent.DOUBLE_CLICK, handleTitleBarDoubleClick);
				
				minWidth = 24;
				
				addEventListener(DragEvent.DRAG_ENTER, handleDragEnter, true);
				addEventListener(DragEvent.DRAG_ENTER, handleDragEnter);
				
				handleTitleTextFormatChange();
				panelNeedsUpdate();
			}
			
			override protected function childrenCreated():void
			{
				super.childrenCreated();
				panelNeedsUpdate();
			}
			
			private function handleCreationComplete():void
			{
				//_dragCanvas.percentWidth = 100;
				//_dragCanvas.percentHeight = 100;
				rawChildren.addChild(_dragCanvas);
				rawChildren.addChild(_moveImage);
				
				if (showBusyIndicator)
				{
					busyIndicator = new BusyIndicator(this as ILinkableObject);
					rawChildren.addChild(busyIndicator);
				}
			}
			
			/**
			 * Override this function to provide a default panel title when the panelTitle session state is undefined.
			 * The panel title will be set when handlePanelTitleChange() is called.
			 * If you need the panel title to be updated, you can call handlePanelTitleChange() directly or as a callback.
			 */
			public function get defaultPanelTitle():String
			{
				return getQualifiedClassName(this).split(':').pop();
			}
			
			// workaround to fix text layout performance problem
			override public function set title(value:String):void
			{
				super.title = value && value.substr(0, 256);
			}
			
			/**
			 * This gets called when the panelTitle session state changes.
			 * If you need the panel title to be updated, you can call this function directly or as a callback.
			 * If you need to override the default panel title, override the "get defaultPanelTitle" accessor function.
			 */
			protected function handlePanelTitleChange():void
			{
				if (panelTitle.value)
				{
					panelTitleFunction.value = '`' + panelTitle.value.split('`').join('\\`') + '`';
					// title will be automatically updated by grouped callback
				}
				else
				{
					title = defaultPanelTitle;
				}
			}
			
			// this gets called as a grouped callback when Weave.root changes and whenever panelTitle can be compiled to a function
			private function evaluatePanelTitle():void
			{
				try
				{
					if (panelTitle.value)
						title = panelTitleFunction.apply(this);
				}
				catch (e:Error)
				{
					//reportError(e);
					title = panelTitle.value;
				}
			}
			
			private function handleTitleTextFormatChange():void
			{
				if (titleBar)
				{
					Weave.properties.panelTitleTextFormat.copyToStyle(titleBar);
					titleTextField.setColor( Weave.properties.panelTitleTextFormat.color.value );
				}
			}
			
			// this metadata tag allows you to specify a percentage value like x="25%" in MXML.
			[PercentProxy("percentX")]
			override public function set x(value:Number):void
			{
				value = Math.round(value);
				super.x = value;
			}
			// this metadata tag allows you to specify a percentage value like y="25%" in MXML.
			[PercentProxy("percentY")]
			override public function set y(value:Number):void
			{
				value = Math.round(value);
				super.y = value;
			}
			
//			[PercentProxy("percentWidth")]
//			override public function set width(value:Number):void
//			{
//				super.width = Math.round(value);
//			}
//			[PercentProxy("percentHeight")]
//			override public function set height(value:Number):void
//			{
//				super.height = Math.round(value);
//			}
			
			[Inspectable(environment="none")]
			public function set percentX(value:Number):void
			{
				panelX.value = "" + value + "%";
			}
			[Inspectable(environment="none")]
			public function set percentY(value:Number):void
			{
				panelY.value = "" + value + "%";
			}
			
			override public function set percentWidth(value:Number):void
			{
				panelWidth.value = "" + value + "%";
			}
			override public function set percentHeight(value:Number):void
			{
				panelHeight.value = "" + value + "%";
			}
			
			private function handlePanelStyleListChange():void
			{
				_overriddenStyles = new Object();
				
				try
				{
					var ss:StyleSheet = new StyleSheet();
					var styleName:String = 'panel';
					ss.parseCSS(styleName + '{' + panelStyleList.value + '}');
					var style:Object = ss.getStyle(styleName);
					for (var propName:String in style)
					{
						var value:* = style[propName];
						
						// the only case that seems to cause problems is Numbers, which will not get parsed properly when 
						// in String format by getStyle(...).  If it is a valid Number, cast it to one
						try {
							_overriddenStyles[propName] = Number(value);
						} catch (e:Error) { } // ok if number parse fails
						
						if (isNaN(_overriddenStyles[propName]))
							_overriddenStyles[propName] = String(value);
					}
				}
				catch(error:Error) { } // ok if style parse fails
				
				// notify style change, just a random style chosen here so we only call it once instead of in the loop above
				// this causes the style changes above to take effect
				styleChanged("headerHeight");
				notifyStyleChangeInChildren("headerHeight", true);
			}
			
			private function handleAddedToStage(event:Event):void
			{
				WeaveAPI.StageUtils.addEventCallback(StageUtils.THROTTLED_MOUSE_MOVE_EVENT, this, handleThrottledMouseMove);
				stage.addEventListener(MouseEvent.MOUSE_MOVE, handleStageMouseMove);
				stage.addEventListener(MouseEvent.MOUSE_UP, handleStageMouseUp);
				parent.addEventListener(ResizeEvent.RESIZE, handleParentResize);
				
				copyCoordinatesFromSessionedProperties();
			}
			private function handleRemovedFromStage(event:Event):void
			{
				WeaveAPI.StageUtils.removeEventCallback(StageUtils.THROTTLED_MOUSE_MOVE_EVENT, handleThrottledMouseMove);
				stage.removeEventListener(MouseEvent.MOUSE_MOVE, handleStageMouseMove);
				stage.removeEventListener(MouseEvent.MOUSE_UP, handleStageMouseUp);
				parent.removeEventListener(ResizeEvent.RESIZE, handleParentResize);
			}
			
			
			/**
			 * This function copies the values for x,y,width,height from the corresponding sessioned properties.
			 * @param singleProperty Set this to one of panelX,panelY,panelWidth,panelHeight to only update that property.
			 */
			internal function copyCoordinatesFromSessionedProperties(singleProperty:LinkableString = null):void
			{
				if (!parent)
					return;
				if (!singleProperty || singleProperty == panelX)
					copyCoordinateFromLinkableString(panelX, parent.width, "x");
				if (!singleProperty || singleProperty == panelY)
					copyCoordinateFromLinkableString(panelY, parent.height, "y");
				if (!singleProperty || singleProperty == panelWidth)
					copyCoordinateFromLinkableString(panelWidth, parent.width, "width", minWidth);
				if (!singleProperty || singleProperty == panelHeight)
					copyCoordinateFromLinkableString(panelHeight, parent.height, "height", minHeight);
				callLater(fixHeight);
			}
			private function fixHeight():void
			{
				if (!parent)
					return;
				if (y + height > parent.height) // rounding error, reproduceable when parent height is 625
					height = parent.height - y;
			}
			
			/**
			 * This function will copy a sessioned string like "75%" as a Number using the calculation "part = whole * percent / 100".
			 * If the sessioned string does not have a "%" sign in it, it will be treated as an absolute coordinate.
			 * @param part The LinkableString contianing the "part" value to use in the calculation.
			 * @param whole The "whole" value in the calculation (parent width or height).
			 * @param destinationPropertyName The name of a property to set on this object (x, y, width, or height) which is the "part" value.
			 */
			private function copyCoordinateFromLinkableString(part:LinkableString, whole:Number, destinationPropertyName:String, minValue:Number = NaN):void
			{
				if (parent == null)
					return;
				
				var numberOrPercent:String = part.value;
				
				// if maximized, use maximized coordinates
				if (maximized.value)
					numberOrPercent = _maximizedCoordinates[destinationPropertyName];
				
				var result:Number = NumberUtils.getNumberFromNumberOrPercent(numberOrPercent, whole);
				
				//trace("handleAbsoluteAndPercentageValues",arguments,numberOrPercent,whole,result);
				if (isFinite(result))
				{
					if (isFinite(minValue))
						result = Math.max(minValue, result);
					this[destinationPropertyName] = result;
				}
			}
			
			private function panelNeedsUpdate():void
			{
				if (!parent)
					return;
				
				// disable highlight when borders are disabled (avoids display bug when corners are rounded)
				setStyle('highlightAlphas', enableBorders.value ? undefined : [0,0]);
				
				_enableMoveResize = (!Weave.properties.dashboardMode.value && enableMoveResize.value) || adminMode;
				if (!enableMoveResize.value && _enableMoveResize)
					_moveImage.alpha = 0.1;
				else
					_moveImage.alpha = 0.25;
				
				if (!maximizable.value)
					maximized.value = false;
				if (!minimizable.value)
					minimized.value = false;
				if (!enableZOrder.value)
					zOrder.value = 0;
				
				invalidateSize();
				invalidateDisplayList();
				updateBorders();
			}
			
			override public function move(x:Number, y:Number):void
			{
				super.move(Math.round(x), Math.round(y));
			}
			
			/**
			 * This function constrains x,y,width,height so that this DraggablePanel is contained in its parent,
			 * then it saves the coordinates (absolute or percentage) to the sessioned properties.
			 */
			protected function constrainAndSaveCoordinates():void
			{
				// keep left side of panel on screen
				if (x + minWidth > parent.width)
					x = parent.width - minWidth;
				// keep top of panel on screen
				if (y + minHeight > parent.height)
					y = parent.height - minHeight;
				// keep right side of panel on screen
				if (x + width < minWidth)
					x = minWidth - width;
				// keep titlebar on screen
				if (y < 0)
					y = 0;
				
				// don't copy coordinates while tool is minimized or maximized
				if (!parent || minimized.value || maximized.value || parent is ISystemManager)
					return;
				
				// init local vars
				var _x:Number = x;
				var _y:Number = y;
				var _right:Number = x + width;
				var _bottom:Number = y + height;
				var _parentWidth:Number = parent.width;
				var _parentHeight:Number = parent.height;
				
				// calculate snap size
				var snapStr:String = Weave.properties.windowSnapGridSize.value;
				var usePercent:Boolean = (Weave.properties.enablePanelCoordsPercentageMode.value && sessionPanelCoordsAsPercentages);
				var snapNum:Number = StandardLib.asNumber(snapStr.replace('%', ''));
				
				// adjust snap to match panel coordinate mode
				if (usePercent != (snapStr.indexOf('%') >= 0))
				{
					if (usePercent)
						snapNum = 100 * snapNum / Math.max(_parentWidth, _parentHeight);
					else
						snapNum = Math.round(Math.max(_parentWidth, _parentHeight) * snapNum / 100)
				}
				if ((usePercent && snapNum <= 0) || (!usePercent && snapNum < 1))
					snapNum = 1;
				
				// convert numbers to percentages if necessary
				if (usePercent)
				{
					_x = 100 * _x / _parentWidth;
					_y = 100 * _y / _parentHeight;
					_right = 100 * _right / _parentWidth;
					_bottom = 100 * _bottom / _parentHeight;
					_parentWidth = 100;
					_parentHeight = 100;
				}
				// truncate width,height
				_parentWidth = Math.floor(_parentWidth / snapNum) * snapNum;
				_parentHeight = Math.floor(_parentHeight / snapNum) * snapNum;
				
				// snap coordinates to grid
				_x = Math.round(_x / snapNum) * snapNum;
				_y = Math.round(_y / snapNum) * snapNum;
				var _width:Number = Math.round(_right / snapNum) * snapNum - _x;
				var _height:Number = Math.round(_bottom / snapNum) * snapNum - _y;
				
				// constrain width,height before x,y because the x,y constrain code depends on width,height
				_width = Math.round(StandardLib.constrain(_width, 0, _parentWidth));
				_height = Math.round(StandardLib.constrain(_height, 0, _parentHeight));
				_x = Math.round(StandardLib.constrain(_x, 0, _parentWidth - _width));
				_y = Math.round(StandardLib.constrain(_y, 0, _parentHeight - _height));
				
				// copy the x,y,width,height coordinates to the corresponding sessioned properties.
				var str:String = usePercent ? '%' : '';
				panelWidth.value = _width + str;
				panelHeight.value = _height + str;
				panelX.value = _x + str;
				panelY.value = _y + str;
				copyCoordinatesFromSessionedProperties();
			}
			
			private function handleResize(event:ResizeEvent):void
			{
				if (!parent)
					return;
				
				if (_dragging || _resizing)
					constrainAndSaveCoordinates();
			}
			
			protected function updateBorders():void
			{
				if (!parent)
					return;
				
				styleChanged("headerHeight");
				notifyStyleChangeInChildren("headerHeight", true);
				updateMoveIcon();
				invalidateDisplayList();
			}
			
			private function updateMoveIcon():void
			{
				//the moveImage will be enabled if the enableMoveIcon is enabled and the panel is moveable and headerHeight is zero.
				_moveImage.visible = _enableMoveResize && !borderIsVisible && (adminMode || !Weave.properties.dashboardMode.value);
			}
			
			protected function get borderIsVisible():Boolean
			{
				if (objectWasDisposed(this))
					return false;
				return enableBorders.value && (parent is ISystemManager || !Weave.properties.dashboardMode.value);
			}
			
			override public function getStyle(styleProp:String):*
			{
				var value:* = null;	
				
				// if we override the borders before the window has been intialized, tools display nothing
				if (initialized)
				{
					// if we are hiding the borders, return style bogus values that cause the borders to hide
					if (!borderIsVisible)
					{
						// override border styles to hide the borders
						
						var borderProps:Array = [
							"borderThicknessTop",
							"borderThicknessBottom",
							"borderThicknessLeft",
							"borderThicknessRight",
							"headerHeight",
							"cornerRadius"
						];
						if (borderProps.indexOf(styleProp) >= 0)
							return 0;
						
						if (styleProp == "dropShadowEnabled")
							return false;
					}
				}
				
				if (_overriddenStyles[styleProp] != undefined )
					value = _overriddenStyles[styleProp];
				else if (styleProp == 'backgroundColor' && isFinite(panelBackgroundColor.value))
					value = panelBackgroundColor.value;
				else if (styleProp == 'borderColor' && isFinite(panelBorderColor.value))
					value = panelBorderColor.value;
				else
					value = super.getStyle(styleProp);
				
				// make sure the headerHeight is at least the size of the cornerRadius,
				// otherwise the stuff inside the panel sticks outside the panel
				if (styleProp == "headerHeight")
					return Math.max(getStyle("cornerRadius"), value );
				
				return value;
			}
			
			/**
			 * The parameter to this function is a generic Event to avoid crashing when parent is systemManager.
			 * If we make the type ResizeEvent, we may get the error "Cannot convert Event to ResizeEvent".
			 */
			private function handleParentResize(event:Event):void
			{
				if (Weave.properties.enablePanelCoordsPercentageMode.value && sessionPanelCoordsAsPercentages)
					copyCoordinatesFromSessionedProperties();
			}
			
			private function handleCloseAlertResult(event:CloseEvent):void
			{			
				if (event.detail == Alert.YES)
				{
					removePanel();
				}
				// no need to do anything else for the other options, in those cases we dont want to close the window so do nothing
			}
			
			private function handleZOrderChange():void
			{
				if (zOrder.value == 0)
				{
					zOrderButton.toolTip = lang(TOOLTIP_ZORDER);
					setupButtonIcons(zOrderButton, [icon_zOrder, icon_zOrderReverse, icon_zOrder]);
					zOrderButton.setStyle("fillColors", [_titleBarButtonBackgroundColor, _titleBarButtonBackgroundColor]);
				}
				else
				{
					if (zOrder.value < 0)
					{
						zOrderButton.toolTip = lang("Always below");
						setupButtonIcons(zOrderButton, [icon_zOrderBelow, icon_zOrderBelow_color, icon_zOrderBelow_color]);
					}
					else
					{
						zOrderButton.toolTip = lang("Always above");
						setupButtonIcons(zOrderButton, [icon_zOrderAbove, icon_zOrderAbove_color, icon_zOrderAbove_color]);
					}
					zOrderButton.setStyle("fillColors", [_titleBarButtonSelectedColor, _titleBarButtonSelectedColor]);
				}
				updatePanelZOrder();
			}
			
			public function toggleMaximized():void
			{
				// toggle maximized state
				maximized.value = !maximized.value;
			}
			
			private function handleMaximizedChange():void
			{
				copyCoordinatesFromSessionedProperties();
				
				setupButtonIcons(maximizeButton, maximized.value ? _unmaximizeIcon : _maximizeIcon);
				maximizeButton.toolTip = maximized.value ? lang("Restore down") : lang(TOOLTIP_MAXIMIZE);
			}
			
			private function handleBorderColorChange():void
			{
				updateBorders();
			}
			
			private function handleBackgroundColorChange():void
			{
				updateBorders();
			}
			private function handleCloseButtonClick():void
			{
				if (Weave.properties.showVisToolCloseDialog.value)
					Alert.show("Are you sure you want to close this window?", "Closing this window...", 1|2, this, handleCloseAlertResult);
				else
					removePanel();
			}
			
			public function removePanel():void
			{
				var owner:ILinkableHashMap = getLinkableOwner(this) as ILinkableHashMap;
				if (owner && owner.getName(this))
				{
					owner.removeObject(owner.getName(this));
					return;
				}
				
				var panels:Array = [this, _controlPanel];
				DraggablePanel.activePanel = null;
				for each (var panel:DraggablePanel in panels)
				{
					if (!panel)
						continue;
					try
					{
						// un-maximize
						panel.maximized.value = false;
						if (panel && panel.parent)
							UIUtils.spark_removeChild(panel.parent, panel);
					}
					catch (e:Error)
					{
						reportError(e);
					}
				}
			}
			
			private function handleMouseDown(event:MouseEvent):void
			{
				var o:DisplayObject = event.target as DisplayObject;
				while (o)
				{
					// stop when clicking on a combo box
					if (o is ComboBox)
						return;
					o = o.parent;
				}
				
				if (!_enableMoveResize)
					return;
				
				if (!parent)
					return;
				
				_leftSideResize = false;
				_rightSideResize = false;
				_topSideResize = false;
				_bottomResize = false;
				
				
				// bring panel to front
				if (parent.getChildIndex(this) < parent.numChildren-1)
					sendWindowToForeground();
				
				
				if (!minimized.value && !maximized.value)
				{
					var status:Object = getResizeStatus(stage.mouseX, stage.mouseY);
					
					if (status.R)
						_rightSideResize = true;
					else if (status.L)
					{
						_rightSideBeforeLeftResize = this.x + this.width;
						_leftSideResize = true;
					}
					
					
					if (status.B)
						_bottomResize = true;
					else if (status.T)
					{
						_bottomSideBeforeTopResize = this.y + this.height;
						_topSideResize = true;
					}
					
					if (getResizeStatus(stage.mouseX, stage.mouseY).resizing)
					{
						_resizing = true;
						event.stopImmediatePropagation();
					}
					else
						_resizing = false;
				}
			}
			
			/**
			 * getResizeStatus
			 * Returns a set of Boolean values corresponding to which sides (top,left,bottom,right) should be resized.
			 * @param stageX The current stage X mouse coordinate.
			 * @param stageY The current stage Y mouse coordinate.
			 * @return An object containing the following properties: T,L,B,R,TL,TR,BL,BR,resizing
			 */
			private function getResizeStatus(stageX:Number, stageY:Number):Object
			{
				var local:Point = globalToLocal(new Point(stageX, stageY));
				var o:Object = new Object();
				
				// get side status values
				o.L = local.x <= resizeBorderThickness;
				o.R = local.x >= this.width - resizeBorderThickness;
				o.T = local.y <= resizeBorderThickness;
				o.B = local.y >= this.height - resizeBorderThickness;
				
				// get side status values for 4x the border thickness (to mimic Windows' corner resize behavior)
				var L4:Boolean = local.x <= resizeBorderThickness * 4;
				var R4:Boolean = local.x >= this.width - resizeBorderThickness * 4;
				var T4:Boolean = local.y <= resizeBorderThickness * 4;
				var B4:Boolean = local.y >= this.height - resizeBorderThickness * 4;
				// corner status is true if mouse is within a square of 4x the border thickness and at least one corresponding side status is true
				o.TL = (T4 && L4) && (o.T || o.L);
				o.TR = (T4 && R4) && (o.T || o.R);
				o.BL = (B4 && L4) && (o.B || o.L);
				o.BR = (B4 && R4) && (o.B || o.R);
				// status for individual sides should be or'd with relevant corner status values
				o.T |= o.TL || o.TR;
				o.L |= o.TL || o.BL;
				o.B |= o.BL || o.BR;
				o.R |= o.TR || o.BR;
				
				// not resizing when coordinates are outside the window
				if (!_mouseRolledOver)
					o.T = o.TL = o.L = o.BL = o.B = o.BR = o.R = o.TR = false;
				
				// we are resizing if we are in the resize area for the top, left, bottom or right
				o.resizing = (o.T || o.L || o.B || o.R);
				
				return o;
			}
			
			// Keep track of the active panel (one that the user has their mouse over) for use in exporting a panel image in the context menu.
			// This is needed so that when the user right clicks on a panel, we know which panel they want to export an image of (cannot tell
			// it from the context menu event).  
			private function handleMouseRollOver(event:MouseEvent):void
			{
				_mouseRolledOver = true;
				DraggablePanel.activePanel = this;
				
				if (_resizing)
					event.stopImmediatePropagation();
			}
			private function handleMouseRollOut(event:MouseEvent):void
			{
				_mouseRolledOver = false;
				DraggablePanel.activePanel = null;
				
				if (_resizing)
					event.stopImmediatePropagation();
				else
					CustomCursorManager.removeCursor(draggablePanelCursorID);
			}
			
			public function sendWindowToForeground():void
			{
				if (_enableMoveResize)
				{
					// put the name of this panel at the end of the hash map names so it appears in front
					var hashMap:ILinkableHashMap = getLinkableOwner(this) as ILinkableHashMap;
					if (hashMap)
						hashMap.setNameOrder([hashMap.getName(this)]);
					else if (parent)
						parent.setChildIndex(this, parent.numChildren - 1);
				}
				updatePanelZOrder();
			}
			
			public function sendWindowToBackground():void
			{
				if (_enableMoveResize)
				{
					// put the name of this panel at the beginning of the hash map names so it appears in back
					var hashMap:ILinkableHashMap = getLinkableOwner(this) as ILinkableHashMap;
					if (hashMap)
					{
						var names:Array = hashMap.getNames();
						names.unshift(hashMap.getName(this));
						hashMap.setNameOrder(names);
					}
				}
				updatePanelZOrder();
			}
			
			private function updatePanelZOrder():void
			{
				var hashMap:ILinkableHashMap = getLinkableOwner(this) as ILinkableHashMap;
				if (hashMap)
				{
					var names:Array = hashMap.getNames();
					var back:Array = [];
					var front:Array = [];
					for (var i:int = 0; i < names.length; i++)
					{
						var name:String = names[i];
						var panel:DraggablePanel = hashMap.getObject(name) as DraggablePanel;
						if (panel)
						{
							if (panel.zOrder.value > 0)
							{
								front.push(name);
								names.splice(i--, 1);
							}
							else if (panel.zOrder.value < 0)
							{
								back.push(name);
								names.splice(i--, 1);
							}
						}
					}
					hashMap.setNameOrder(back.concat(names).concat(front));
				}
			}
			
			private function handleTitleBarDoubleClick(event:MouseEvent):void
			{
				// do not allow double click on any of the control buttons
				if (event.target is Button)
					return;
				
				toggleMaximized();
			}
			private function handleTitleBarMouseDown(event:MouseEvent):void
			{
				if (!_enableMoveResize || maximized.value)
					return;
				
				if (!parent)
					return;
				
				sendWindowToForeground();
				
				_initialTitleBarMouseDownPoint = globalToLocal(new Point(stage.mouseX, stage.mouseY));
				
				if (getResizeStatus(stage.mouseX, stage.mouseY).resizing)
					_dragging = false;
				else
					_dragging = true;
				
				
				// we don't want to allow resizing or dragging if we are on any of the buttons
				if (event.target is Button || event.target is SpriteAsset)
				{
					_dragging = false;
					_resizing = false;
				}
			}
			
			private function handleStageMouseUp(event:MouseEvent):void
			{
				_dragging = false;
				_resizing = false;
				_leftSideResize = false;
				_rightSideResize = false;
				_topSideResize = false;
				_bottomResize = false;
			}
			private function handleStageMouseMove(event:MouseEvent):void
			{
				// make sure cursors dont keep changing while resizing:  !_resizing
				if (parent && !_resizing && !minimized.value && !maximized.value)
				{
					var status:Object = getResizeStatus(stage.mouseX, stage.mouseY);
					var resizeCursorName:String = null;
					// check to see if the mouse is in the top left (TL) or bottom right (BR) corner
					if (status.TL || status.BR)
						resizeCursorName = CURSOR_RESIZE_TOPLEFT_BOTTOMRIGHT;
						// check to see if the mouse is in the top right (TR) or bottom left (BL) corner
					else if (status.TR || status.BL)
						resizeCursorName = CURSOR_RESIZE_TOPRIGHT_BOTTOMLEFT;
						// check to see if the mouse is on the left or right side (LR)
					else if (status.L || status.R)
						resizeCursorName = CURSOR_RESIZE_LEFT_RIGHT;
						// check to see if the mouse is on the top or bottom side
					else if (status.T || status.B)
						resizeCursorName = CURSOR_RESIZE_TOP_BOTTOM;
					
					CustomCursorManager.removeCursor(draggablePanelCursorID);
					if ( resizeCursorName!= null && !event.buttonDown && _enableMoveResize)
					{
						if (debug)
							weaveTrace(debugId(this), resizeCursorName, debugId(event), debugId(event.target));
						
						try
						{
							draggablePanelCursorID = CustomCursorManager.showCursor(resizeCursorName);
						}
						catch (e:Error)
						{
							draggablePanelCursorID = -1;
							reportError(e);
						}
					}
				}
				
				if (_dragging || _resizing)
					event.stopImmediatePropagation();
				
				handleThrottledMouseMove();
			}
			
			private function handleThrottledMouseMove():void
			{
				// don't do anything if this panel is not added to the stage.
				if (!parent)
					return;
				
				if (!_enableMoveResize)
					return;
				
				var parentMousePoint:Point = new Point(parent.mouseX, parent.mouseY);
				
				if (_dragging)
				{
					// constrain the window X location to be between 0 and the right side of the window
					var newX:int = parentMousePoint.x - _initialTitleBarMouseDownPoint.x;
					// constrain the window Y location to be between 0 and the bottom of the window
					var newY:int = parentMousePoint.y - _initialTitleBarMouseDownPoint.y;
					this.move(newX, newY);
					constrainAndSaveCoordinates();
				}
				if (_resizing)
				{
					if (_rightSideResize)
					{
						this.width = StandardLib.constrain( (parentMousePoint.x - this.x), minWidth, (parent.width - this.x) );
					}
					else if (_leftSideResize)
					{
						this.x = StandardLib.constrain( (parentMousePoint.x), 0, _rightSideBeforeLeftResize - minWidth );
						this.width = (_rightSideBeforeLeftResize - this.x);
					}
					if (_bottomResize)
					{
						this.height = StandardLib.constrain( (parentMousePoint.y - this.y), minHeight, (parent.height - this.y) );
					}
					else if (_topSideResize)
					{
						this.y = StandardLib.constrain( (parentMousePoint.y), 0, _bottomSideBeforeTopResize - minHeight );
						this.height = (_bottomSideBeforeTopResize - this.y);
					}
					constrainAndSaveCoordinates();
				}
			}
			
			public function toggleControlPanel():void
			{
				if (_controlPanel)
				{
					if (!_controlPanel.parent)
						PopUpManager.addPopUp(_controlPanel, WeaveAPI.topLevelApplication as UIComponent);
					_controlPanel.sendWindowToForeground();
					_controlPanel.reposition();
					_controlPanel.copyCoordinatesFromSessionedProperties();
				}
				else
				{
					SessionStateEditor.openDefaultEditor(this);
				}
			}
			
			/**
			 * This will reposition the window with default coordinates.
			 */
			public function reposition():void
			{
				panelX.value = '' + int(2 + Math.random() * 6) + "%";
				panelY.value = '' + int(2 + Math.random() * 6) + "%";
				panelWidth.value = "50%";
				panelHeight.value = "50%";
			}
			
			private function setupButtonIcons(button:Button, iconClassOrArray_0icon_1over_2down:Object):void
			{
				var icons:Array = iconClassOrArray_0icon_1over_2down as Array;
				var icon:Class = icons ? icons[0] : iconClassOrArray_0icon_1over_2down as Class;
				
				button.setStyle("icon", icon);
				button.setStyle("overIcon", (icons && icons[1]) || icon);
				button.setStyle("downIcon", (icons && icons[2]) || icon);
			}
			
			private function setupControlButton(button:Button, iconClassOrArray_0icon_1over_2down:Object, clickHandler:Function, tooltip:String = null):void
			{
				setupButtonIcons(button, iconClassOrArray_0icon_1over_2down);
				
				button.toolTip = lang(tooltip);
				
				button.setStyle("fontFamily",    "Arial");
				button.setStyle("color", 0x000000);
				button.setStyle("paddingBottom", 0);
				button.setStyle("paddingLeft",   0);
				button.setStyle("paddingRight",  0);
				button.setStyle("paddingTop",    0);
				button.setStyle("fontSize",      12);
				button.setStyle("fontWeight",    "bold");
				button.setStyle("cornerRadius",  0);
				
				button.setStyle("fillAlphas", [1,1] );
				button.setStyle("fillColors", [_titleBarButtonBackgroundColor, _titleBarButtonBackgroundColor] );
				
				button.addEventListener(MouseEvent.MOUSE_DOWN, function (event:MouseEvent):void { event.stopPropagation(); });
				
				if(clickHandler != null)
				{
					var buttonListener:Function = function(e:MouseEvent):*
					{
						clickHandler();
						e.stopImmediatePropagation();
					};
					button.addEventListener(MouseEvent.CLICK, buttonListener);
				}
				button.width = buttonSize;
				button.height = buttonSize;
				button.buttonMode = true;
				
				button.graphics.clear();
				button.graphics.beginFill(0,0);
				button.graphics.lineStyle(0,0,0);
				button.graphics.drawRect(-spaceBetweenButtons/2, -spaceBetweenButtons/2, buttonSize + spaceBetweenButtons, buttonSize + spaceBetweenButtons);
				button.graphics.endFill();
			}
			
			public function getTotalIconAreaWidth():int 
			{
				return getLeftIconAreaWidth() + getRightIconAreaWidth();
			}
			
			private function getLeftIconAreaWidth():int
			{
				var w:int = buttonOffsetFromSide;
				for each (var button:Button in [userControlButton, subMenuButton, attributeButton])
					if (button.parent)
						w += buttonSize + spaceBetweenButtons;
				return w;
			}
			
			private function getRightIconAreaWidth():int
			{
				var w:int = buttonOffsetFromSide;
				for each (var button:Button in [zOrderButton, minimizeButton, maximizeButton, closePanelButton])
					if (button.parent)
						w+= buttonSize + spaceBetweenButtons;
				return w;
			}
			
			private var _prevShouldShowAttributeButton:Boolean = false;
			private function updateButtonsIfSelectableAttributesChanged():void
			{
				if (_prevShouldShowAttributeButton != shouldShowAttributeButton)
				{
					_prevShouldShowAttributeButton = !_prevShouldShowAttributeButton;
					updateButtons();
				}
			}
			
			private function get shouldShowAttributeButton():Boolean
			{
				return Weave.properties.enableToolControls.value
					&& this is IObjectWithSelectableAttributes
					&& (this as IObjectWithSelectableAttributes).getSelectableAttributes().length;
			}
			
			private function updateButtons():void
			{
				// don't do anything if not added to a parent to avoid errors like the following:
				/*
				ArgumentError: Error #2004: One of the parameters is invalid.
				at flash.display::Graphics/drawRoundRect()
				at mx.skins::ProgrammaticSkin/drawRoundRect()[C:\autobuild\3.5.0\frameworks\projects\framework\src\mx\skins\ProgrammaticSkin.as:763]
				at mx.skins.halo::ButtonSkin/updateDisplayList()[C:\autobuild\3.5.0\frameworks\projects\framework\src\mx\skins\halo\ButtonSkin.as:217]
				at mx.skins::ProgrammaticSkin/validateDisplayList()[C:\autobuild\3.5.0\frameworks\projects\framework\src\mx\skins\ProgrammaticSkin.as:421]
				at mx.managers::LayoutManager/validateDisplayList()[C:\autobuild\3.5.0\frameworks\projects\framework\src\mx\managers\LayoutManager.as:622]
				at mx.managers::LayoutManager/doPhasedInstantiation()[C:\autobuild\3.5.0\frameworks\projects\framework\src\mx\managers\LayoutManager.as:695]
				at Function/http://adobe.com/AS3/2006/builtin::apply()
				at mx.core::UIComponent/callLaterDispatcher2()[C:\autobuild\3.5.0\frameworks\projects\framework\src\mx\core\UIComponent.as:8744]
				at mx.core::UIComponent/callLaterDispatcher()[C:\autobuild\3.5.0\frameworks\projects\framework\src\mx\core\UIComponent.as:8684]
				*/
				if (!parent)
				{
					callLater(updateButtons);
					return;
				}
				
				// centered vertically
				var offsetFromTop:int = Math.ceil((getHeaderHeight() - buttonSize) / 2 + getStyle("borderThicknessTop") / 2);
				var leftButtonX:int = buttonOffsetFromSide;
				var rightButtonX:int = unscaledWidth - buttonSize - buttonOffsetFromSide + 1;
				
				// we only need to update title buttons if the height is > 0, otherwise do not show the buttons
				var showButtons:Boolean = getStyle("headerHeight") > 0;
				var buttons:Array, conditions:Array, i:int, button:Button;
				
				// left side
				buttons = [userControlButton, subMenuButton, attributeButton];
				conditions = [
					Weave.properties.enableToolControls.value && _controlPanel,
					enableSubMenu.value,
					shouldShowAttributeButton
				];
				for (i = 0; i < buttons.length; i++)
				{
					button = buttons[i];
					if (showButtons && leftButtonX < rightButtonX && conditions[i])
					{
						if (titleBar != button.parent)
						{
							button.setStyle("cornerRadius", buttonRadius.value);
							button.y = offsetFromTop;
							button.width = buttonSize;
							button.height = buttonSize;
							titleBar.addChild(button);
						}
						button.x = leftButtonX;
						leftButtonX += buttonSize + spaceBetweenButtons;
					}
					else if (titleBar == button.parent)
						titleBar.removeChild(button);
				}
				
				// right side
				buttons = [closePanelButton, maximizeButton, minimizeButton, zOrderButton];
				conditions = [closeable.value, maximizable.value, minimizable.value, enableZOrder.value];
				for (i = 0; i < buttons.length; i++)
				{
					button = buttons[i];
					if (showButtons && leftButtonX < rightButtonX && conditions[i])
					{
						if (titleBar != button.parent)
						{
							button.setStyle("cornerRadius", buttonRadius.value);
							button.y = offsetFromTop;
							button.width = buttonSize;
							button.height = buttonSize;
							titleBar.addChild(button);
						}
						button.x = rightButtonX;
						rightButtonX -= buttonSize + spaceBetweenButtons;
					}
					else if (titleBar == button.parent)
						titleBar.removeChild(button);
				}
				updateBorders();
				layoutChrome(unscaledWidth, unscaledHeight);
			}
			
			override protected function layoutChrome(unscaledWidth:Number, unscaledHeight:Number):void
			{
				super.layoutChrome(unscaledWidth, unscaledHeight);
				// shift title text to make room for buttons on the upper-left corner
				if (!titleTextField)
					return;
				
				titleTextField.x = getLeftIconAreaWidth();	
				// modifed from Panel.as code for the titleTextField
				//getLeftIconAreaWidth... getRightIconAreaWidth should be getRightIconAreaWidth
				// the text has to be set each time because truncateToFit() is destructive of the textField's text variable
				titleTextField.text = title;
				titleTextField.width = Math.max(0, unscaledWidth - titleTextField.x - getRightIconAreaWidth());
				titleTextField.truncateToFit();
			}
			
			override protected function commitProperties():void
			{
				minHeight = borderMetrics.top + borderMetrics.bottom;
				
				super.commitProperties();
			}
			
			override protected function updateDisplayList(unscaledWidth:Number, unscaledHeight:Number):void
			{
				// force pixel boundaries
				unscaledWidth = Math.round(unscaledWidth);
				unscaledHeight = Math.round(unscaledHeight);
				super.updateDisplayList(unscaledWidth, unscaledHeight);
				
				updateButtons();
				
				if (controlBar)
					controlBar.visible = !minimized.value;
				
				_dragCanvas.graphics.clear();
				
				if (isNaN(unscaledHeight))
					return;
				
				// draw invisible halo around the inside of the window to intercept mouse events for resizing
				_dragCanvas.width = width;
				_dragCanvas.height = height;
				UIUtils.drawInvisibleHalo(_dragCanvas, -resizeBorderThickness);

				if (_enableMoveResize || _moveImage.visible)
				{
					_dragCanvas.graphics.lineStyle(1, borderIsVisible ? thinBorderOverlayColor : thinBorderColor, thinBorderAlpha);
					_dragCanvas.graphics.drawRect(0, 0, Math.round(width)-1, Math.round(height)-1);
				}
			}
			
			protected function handleAttributeButtonClick():void
			{
				openAttributeSelector();
			}
			
			public function openAttributeSelector(attrIndex:int = 0):AttributeSelectorPanel
			{
				var tool:IObjectWithSelectableAttributes = this as IObjectWithSelectableAttributes;
				if (tool)
				{
					var attrs:Array = tool.getSelectableAttributes();
					var names:Array = tool.getSelectableAttributeNames();
					if (attrs && attrs[attrIndex])
					{
						return AttributeSelectorPanel.open(attrs[attrIndex], names[attrIndex]);
					}
				}
				return null;
			}
			
			protected function handleMinimizeButtonClick():void
			{
				var hashMap:ILinkableHashMap = getLinkableOwner(this) as ILinkableHashMap;
				if (WeaveAPI.StageUtils.shiftKey && hashMap)
				{
					for each (var panel:DraggablePanel in hashMap.getObjects(DraggablePanel))
						panel.minimizePanel();
				}
				else
				{
					minimizePanel();
				}
			}
			
			private function handleMinimizedChange():void
			{
				if (minimized.value) // minimize
				{
					enabled = visible = false;
					if (!minimizedComponentVersion)
						minimizedComponentVersion = VisTaskbar.instance.addMinimizedComponent(this, restorePanel);
				}
				else // restore
				{
					enabled = visible = true;
					if (minimizedComponentVersion)
						VisTaskbar.instance.removeMinimizedComponent(minimizedComponentVersion);
					minimizedComponentVersion = null;
					copyCoordinatesFromSessionedProperties();
					
					// this fixes the display bugs that occur when restoring a minimized window
					updateBorders();
				}
			}
			
			public function minimizePanel():void
			{
				if (_controlPanel)
					_controlPanel.removePanel();
				minimized.value = true;
			}
			
			public function restorePanel():void
			{
				sendWindowToForeground();
				minimized.value = false;
			}
			
			/**
			 * This will be called when this object is no longer needed.
			 * Classes that extend this class should override this function and call super.dispose().
			 */
			public function dispose():void
			{
				CustomCursorManager.removeCursor(draggablePanelCursorID);
				
				if (minimizedComponentVersion)
					VisTaskbar.instance.removeMinimizedComponent(minimizedComponentVersion);
				minimizedComponentVersion = null;
				
				removeEventListener(MouseEvent.MOUSE_DOWN, handleMouseDown, true);
				removeEventListener(DragEvent.DRAG_ENTER, handleDragEnter, true);
				removeEventListener(DragEvent.DRAG_ENTER, handleDragEnter);
				
				if (titleBar != null)
				{
					titleBar.removeEventListener(MouseEvent.MOUSE_DOWN, handleTitleBarMouseDown);
					titleBar.removeEventListener(MouseEvent.DOUBLE_CLICK, handleTitleBarDoubleClick);
				}
			}
			
			private function handleDragEnter(event:DragEvent):void
			{
				restorePanel();
			}
			
			public function get escapeKeyClosesPanel():Boolean
			{
				return _escapeKeyClosesPanel;
			}
			
			/**
			 * Set this to true to allow the ESCAPE key to close this panel.
			 */
			public function set escapeKeyClosesPanel(value:Boolean):void
			{
				_escapeKeyClosesPanel = value;
				if (value)
					WeaveAPI.StageUtils.addEventCallback(KeyboardEvent.KEY_DOWN, this, handleKeyDown);
				else
					WeaveAPI.StageUtils.removeEventCallback(KeyboardEvent.KEY_DOWN, handleKeyDown);
			}
			
			private function handleKeyDown():void
			{
				var event:KeyboardEvent = WeaveAPI.StageUtils.keyboardEvent;
				if (parent && event && event.keyCode == Keyboard.ESCAPE)
				{
					var i:int;
					
					// if there is a child with name=modalWindow, don't handle escape key
					for (i = 0; i < systemManager.numChildren; i++)
						if (systemManager.getChildAt(i).name == 'modalWindow')
							return;
					
					// find the top-most draggable panel with escapeKeyClosesPanel=true
					for (i = parent.numChildren; i--;)
					{
						var panel:DraggablePanel = parent.getChildAt(i) as DraggablePanel;
						if (panel && panel.escapeKeyClosesPanel)
						{
							if (panel == this)
								panel.handleEscapeKey();
							// we don't want to do anything more
							return;
						}
					}
				}
			}
			
			/**
			 * This function gets called when the user presses ESCAPE and escapeKeyClosesPanel has been set to true.
			 */
			protected function handleEscapeKey():void
			{
				// don't remove immediately because we don't want multiple windows to close in handleKeyDown()
				callLater(removePanel);
			}
			
			
			
			
			
			
			/**************************************************************************
			 ************************** BEGIN STATIC SECTION **************************/
			
			public static const TOOLTIP_CONTROLS:String = "Change settings";
			public static const TOOLTIP_SUBMENU:String = "Menu";
			public static const TOOLTIP_ATTRIBUTES:String = "Change attributes";
			public static const TOOLTIP_ZORDER:String = "Toggle always above or below";
			public static const TOOLTIP_MINIMIZE:String = "Minimize";
			public static const TOOLTIP_MAXIMIZE:String = "Maximize";
			public static const TOOLTIP_CLOSE:String = "Close";
			
			private static const _instances:Dictionary = new Dictionary();
			private static const _maximizedCoordinates:Object = {x: "0%", y: "0%", width: "100%", height: "100%"};
			private static const resizeBorderThickness:int = 5;
			public static var adminMode:Boolean = false;
			public static var activePanel:DraggablePanel = null;
			public static var thinBorderOverlayColor:uint = 0xFFFFFF;
			public static var thinBorderColor:uint = 0;
			public static var thinBorderAlpha:Number = 0.1;
			
			/**
			 * This function will create and reuse a static instance of each type of DraggablePanel requested.
			 * @param classDef A Class extending DraggablePanel.
			 * @return The static instance of the given class.
			 */
			public static function openStaticInstance(draggablePanelClass:Class):*
			{
				var qname:String = getQualifiedClassName(draggablePanelClass);
				var dpqname:String = getQualifiedClassName(DraggablePanel);
				if (!ClassUtils.classExtends(qname, dpqname))
					throw new Error(qname + " does not extend " + dpqname);
				
				var instance:DraggablePanel = _instances[draggablePanelClass];
				if (!instance)
				{
					_instances[draggablePanelClass] = instance = new draggablePanelClass() as DraggablePanel;
					instance.enableZOrder.value = false;
				}
				if (!instance.parent)
					PopUpManager.addPopUp(instance, WeaveAPI.topLevelApplication as UIComponent);
				instance.restorePanel();
				
				instance.reposition();
				instance.copyCoordinatesFromSessionedProperties();
				
				var xSpace:Number = Math.max(0, instance.parent.width - instance.width);
				var ySpace:Number = Math.max(0, instance.parent.height - instance.height);
				var xSpread:Number = Math.min(100, xSpace / 4);
				var ySpread:Number = Math.min(100, ySpace / 4);
				instance.panelX.value = String(int(xSpace/2 - xSpread/2 + xSpread * Math.random()));
				instance.panelY.value = String(int(ySpace/2 - ySpread/2 + ySpread * Math.random()));
				
				return instance;
			}
			
			public static function get activePanelName():String
			{
				return Weave.root.getName(activePanel);
			}
			
			public static function getTopPanel():DraggablePanel
			{
				return Weave.root.getObjects(DraggablePanel).pop();
			}
			public static function getTopPanelName():String
			{
				return Weave.root.getName(getTopPanel());
			}
			
			/**
			 * @return an Array containing all DraggablePanels on stage that are not minimized
			 *
			 * @author kmanohar
			 */		
			public static function getWindowsOnStage():Array
			{
				var panels:Array = WeaveAPI.globalHashMap.getObjects(DraggablePanel);
				var panelsOnStage:Array = [];
				
				for each (var panel:DraggablePanel in panels)
				{
					if (!panel.minimized.value) 
						panelsOnStage.push(panel);
				}
				return panelsOnStage;
			}
			/**
			 * This function tiles all the DraggablePanels on stage
			 * 
			 * @TODO create a ui for this so the user can specify how to divide the stage
			 * 
			 * @author kmanohar
			 */		
			public static function tileWindows():void
			{
				var panels:Array = getWindowsOnStage();
				var numPanels:uint = panels.length;
				if (!numPanels)
					return;
				
				var gridLength:Number = Math.ceil(Math.sqrt(numPanels));
				
				var rows:uint = gridLength; 
				var columns:uint = gridLength;
				
				if (gridLength*gridLength != numPanels)
				{	
					rows = Math.round(Math.sqrt(numPanels));
					columns = gridLength;
				}			
				
				var xPos:Number = 0;
				var yPos:Number = 0;
				var firstPanel:DraggablePanel = panels[0] as DraggablePanel;
				var taller:Boolean = firstPanel.parent.width < firstPanel.parent.height;
				var width:Number = 100/(taller ? rows : columns);
				var height:Number = 100/(taller ? columns : rows);
				
				var i:int = 0;
				for each (var dp:DraggablePanel in panels)
				{				
					dp.panelX.value = xPos.toString() + "%";
					dp.panelY.value = yPos.toString() + "%";
					
					dp.panelHeight.value = height.toString() + "%";
					dp.panelWidth.value = width.toString() + "%";
					if (i == (panels.length - 1))
					{
						// expand to fill the width
						dp.panelWidth.value = (100-xPos).toString() + "%";
					}
					
					xPos += width;
					if (xPos >= 100)
						xPos = 0;
					if (!xPos)
						yPos += height ;
					i++;
				}
			}
			/**
			 * This function arranges all DraggablePanels along a diagonal
			 * 
			 * @author kmanohar
			 */
			public static function cascadeWindows():void
			{
				var panels:Array = getWindowsOnStage();
				if (!panels.length)
					return;
				
				var increment:Number = 50/panels.length;
				var dist:Number = 0 ;
				
				for each (var dp:DraggablePanel in panels)
				{				
					dp.panelX.value = dp.panelY.value = dist.toString()+"%";			
					dp.panelHeight.value = dp.panelWidth.value = "50%" ;	
					
					dist += increment;
				}
			}
			
			/**
			 * Embedded cursors
			 */
			public static const CURSOR_RESIZE_TOP_BOTTOM:String = "resizeTopBottom";
			public static const CURSOR_RESIZE_LEFT_RIGHT:String = "resizeLeftRight";
			public static const CURSOR_RESIZE_TOPLEFT_BOTTOMRIGHT:String = "resizeTLBR";
			public static const CURSOR_RESIZE_TOPRIGHT_BOTTOMLEFT:String = "resizeTRBL";
			[Embed(source="/weave/resources/images/resize_TB.png")] private static var _resizeTBCursor:Class;
			[Embed(source="/weave/resources/images/resize_LR.png")] private static var _resizeLRCursor:Class;
			[Embed(source="/weave/resources/images/resize_TL-BR.png")] private static var _resizeTLBRCursor:Class;
			[Embed(source="/weave/resources/images/resize_TR-BL.png")] private static var _resizeTRBLCursor:Class;
			CustomCursorManager.registerEmbeddedCursor(CURSOR_RESIZE_TOP_BOTTOM, _resizeTBCursor, NaN, NaN);
			CustomCursorManager.registerEmbeddedCursor(CURSOR_RESIZE_LEFT_RIGHT, _resizeLRCursor, NaN, NaN);
			CustomCursorManager.registerEmbeddedCursor(CURSOR_RESIZE_TOPLEFT_BOTTOMRIGHT, _resizeTLBRCursor, NaN, NaN);
			CustomCursorManager.registerEmbeddedCursor(CURSOR_RESIZE_TOPRIGHT_BOTTOMLEFT, _resizeTRBLCursor, NaN, NaN);
			
			/**
			 * Embedded icons
			 */
			[Embed(source="/weave/resources/images/panMode.png")] private static var MoveIcon:Class;
			
			[Embed(source="/weave/resources/images/gear6_13x13_h.png")] private static var _userControlIcon:Class;
			[Embed(source="/weave/resources/images/gear6_13x13_v.png")] private static var _userControlIcon2:Class;
			[Embed(source="/weave/resources/images/menu_9x7.png")] private static var _subMenuIcon:Class;
			[Embed(source="/weave/resources/images/alpha_11x11.png")] private static var _attributeIcon:Class;
			
			[Embed(source="/weave/resources/images/z-order.png")] private static var icon_zOrder:Class;
			[Embed(source="/weave/resources/images/z-order-reverse.png")] private static var icon_zOrderReverse:Class;
			
			[Embed(source="/weave/resources/images/always-on-top-gray.png")] private static var icon_zOrderAbove:Class;
			[Embed(source="/weave/resources/images/always-on-top.png")] private static var icon_zOrderAbove_color:Class;
			
			[Embed(source="/weave/resources/images/always-on-back-gray.png")] private static var icon_zOrderBelow:Class;
			[Embed(source="/weave/resources/images/always-on-back.png")] private static var icon_zOrderBelow_color:Class;
			
			[Embed(source="/weave/resources/images/minimize_icon.png")] private static var _minimizeIcon:Class;
			[Embed(source="/weave/resources/images/maximize_icon.png")] private static var _maximizeIcon:Class;
			[Embed(source="/weave/resources/images/unmaximize_icon.png")] private static var _unmaximizeIcon:Class;
			
			[Embed(source="/weave/resources/images/close_icon.png")] private static var _closeIcon:Class;
			[Embed(source="/weave/resources/images/close_icon_red.png")] private static var _closeIconColor:Class;
			[Embed(source="/weave/resources/images/close_icon_red2.png")] private static var _closeIconColor2:Class;
			
			/************************** END STATIC SECTION **************************
			 ************************************************************************/
			
			/**
			 * Backwards compatibility
			 */
			[Deprecated(replacement="panelTitle")] public function set toolTitle(value:String):void { panelTitle.value = value; }
			[Deprecated(replacement="enableBorders")] public function set hideBorders(value:Boolean):void { enableBorders.value = !value; }
			[Deprecated(replacement="enableMoveResize")] public function set draggable(value:Boolean):void { enableMoveResize.value = value; }
			[Deprecated(replacement="enableMoveResize")] public function set resizeable(value:Boolean):void { enableMoveResize.value = value; }
			[Deprecated(replacement="zOrder")] public function set pinned(value:Boolean):void { if (value) zOrder.value = 1; }
			[Deprecated(replacement="zOrder")] public function set pinnedToBack(value:Boolean):void { if (value) zOrder.value = -1; }
			[Deprecated(replacement="enableZOrder")] public function set pinnable(value:Boolean):void { enableZOrder.value = value; }
			[Deprecated(replacement="enableZOrder")] public function set pinnableToBack(value:Boolean):void { if (value) enableZOrder.value = true; }
		]]>
	</mx:Script>
</mx:TitleWindow>
