<?xml version="1.0" encoding="utf-8"?>
<!--
/*
    Weave (Web-based Analysis and Visualization Environment)
    Copyright (C) 2008-2011 University of Massachusetts Lowell

    This file is a part of Weave.

    Weave is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License, Version 3,
    as published by the Free Software Foundation.

    Weave is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Weave.  If not, see <http://www.gnu.org/licenses/>.
*/
-->

<!--
BinningDefinitionEditor

@sanbalagan
-->
<mx:VBox xmlns:ui ="weave.ui.*"
		 xmlns:mx="http://www.adobe.com/2006/mxml" 
		 xmlns="weave.ui.*"
		 implements="weave.api.core.ILinkableObject"
		 width="{NaN}" height="{NaN}"
		 verticalGap="2" paddingLeft="3" paddingRight="3" paddingBottom="3">
	<!-- NOTE: setting the panel's width and height to NaN will force it to resize to the children... -->
		<mx:Button label="Edit Names" click="editNames()"/>
		<mx:Label text="Binning Type:"/>
		<mx:RadioButtonGroup id="typeGroup"/>
		
		<mx:HBox styleName="group-hbox-style" width="100%">
			<mx:RadioButton id="simpleRadio" label="Equally spaced" groupName="typeGroup" selected="true" width="200"/>
			<mx:HBox enabled="{simpleRadio.selected}">
				<mx:Label text="Number of Bins:" width="120"/>
				<mx:NumericStepper minimum="2" maximum="20" stepSize="1" id="numOfBins"/>
				<!--
					<TextInputWithRegex change="saveSessionState()" id="numOfBins" width="40" enter="handleInputEnter(event)" restrict="0-9"/>	
				-->
				<ui:HelpComponent helpText="Example: If your data is between 0 and 100 and you specify 4 bins, the following bins will be created: [0,25] [25,50] [50,75] [75,100]"/>
			</mx:HBox>
		</mx:HBox>
		
		<mx:HRule width="100%"/>
		
		<mx:HBox styleName="group-hbox-style" width="100%">
			<mx:RadioButton id="ncRadio" label="Custom Split" groupName="typeGroup" width="200"/>
			<ui:CustomSplitBinningEditor id="csEditor" enabled="{ncRadio.selected}"/>
		</mx:HBox>
		
		<mx:HRule width="100%"/>
		
		<mx:HBox styleName="group-hbox-style" width="100%">
			<mx:RadioButton id="quantileRadio" label="Quantile" groupName="typeGroup" width="200"/>
			<mx:HBox enabled="{quantileRadio.selected}">
				<mx:Label text="Reference Quantile:" width="120"/>
				<mx:TextInput id="refQuantile" width="40"/>	
				<ui:HelpComponent helpText="Example: If you specify 0.25, four bins will be created that each contain 25% of your data in sorted order"/>
			</mx:HBox>		
		</mx:HBox>
		
		<mx:HRule width="100%"/>
		
		<mx:HBox styleName="group-hbox-style" width="100%">
			<mx:RadioButton  id="equalIntervalRadio" label="Equal Interval" groupName="typeGroup" width="200"/>
			<mx:HBox enabled="{equalIntervalRadio.selected}">
				<mx:Label text="Data Interval:" width="120"/>				 
				<mx:TextInput id="dataInterval" width="40"/>				
				<ui:HelpComponent helpText="Example: If your data is between 0 and 100 and you specify an interval of 25, four bins will be created: [0,25] [25,50] [50,75] [75,100]"/>
			</mx:HBox>	
		</mx:HBox>
		
		<mx:HRule width="100%"/>
		
		<mx:HBox styleName="group-hbox-style" width="100%">	
			<mx:RadioButton id="sdRadio" label="Standard Deviation" groupName="typeGroup" width="200"/>
			<mx:HBox enabled="{sdRadio.selected}">
				<mx:Label text="SD Number:" width="120"/>				 
				<mx:TextInput id="SD" width="40"/>
				<ui:HelpComponent helpText="One bin will be created for each standard deviation above and below the mean value.  Specifying 'SD Number' as 3 will create 6 bins."/>
			</mx:HBox>
		</mx:HBox>
	
		<mx:HRule width="100%"/>
		
		<mx:HBox styleName="group-hbox-style" width="100%">	
			<mx:RadioButton id="catRadio" label="All categories (string values)" groupName="typeGroup" width="200"/>
			<ui:HelpComponent helpText="One bin will be created for each unique string value in the column."/>
		</mx:HBox>
	
	<!--<mx:ControlBar>
		<mx:Button label="Apply" click="saveSessionState()"/>
	</mx:ControlBar>-->
	
	<mx:Script>
		<![CDATA[
			import mx.collections.ArrayCollection;
			import mx.core.IFlexDisplayObject;
			import mx.events.FlexEvent;
			import mx.managers.PopUpManager;
			import mx.utils.StringUtil;
			
			import weave.Weave;
			import weave.api.WeaveAPI;
			import weave.api.core.ILinkableObject;
			import weave.api.data.IBinningDefinition;
			import weave.api.getCallbackCollection;
			import weave.api.linkBindableProperty;
			import weave.api.linkSessionState;
			import weave.api.newLinkableChild;
			import weave.core.LinkableDynamicObject;
			import weave.core.LinkableNumber;
			import weave.core.SessionManager;
			import weave.data.AttributeColumns.BinnedColumn;
			import weave.data.BinningDefinitions.CategoryBinningDefinition;
			import weave.data.BinningDefinitions.CustomSplitBinningDefinition;
			import weave.data.BinningDefinitions.DynamicBinningDefinition;
			import weave.data.BinningDefinitions.EqualIntervalBinningDefinition;
			import weave.data.BinningDefinitions.ExplicitBinningDefinition;
			import weave.data.BinningDefinitions.QuantileBinningDefinition;
			import weave.data.BinningDefinitions.SimpleBinningDefinition;
			import weave.data.BinningDefinitions.StandardDeviationBinningDefinition;
			import weave.utils.EventUtils;
			
			/**make UI to access this for things using a binned column**/
			
			public const binnedColumn:BinnedColumn = newLinkableChild(this, BinnedColumn); 
			override protected function childrenCreated():void
			{
				super.childrenCreated();
				
				binnedColumn.addGroupedCallback(this,handleBinnedColumnChange,true);
				
				var delayedCallback:Function = EventUtils.generateDelayedCallback(saveSessionState, []);
				for each (var obj:IEventDispatcher in [numOfBins, csEditor.splitValues, refQuantile, dataInterval, SD, typeGroup])
					obj.addEventListener(Event.CHANGE, delayedCallback);
			}
			
			
			private function handleBinnedColumnChange():void
			{
				if(!initialized)
				{
					callLater(handleBinnedColumnChange);
					return;
				}
				
				var def:IBinningDefinition = binnedColumn.binningDefinition.internalBinningDefinition;
				
				if(def is SimpleBinningDefinition)
				{
					var _sBD:SimpleBinningDefinition = def as SimpleBinningDefinition;
					typeGroup.selection = simpleRadio;
					numOfBins.value = _sBD.numberOfBins.value;
				}
				else if(def is CustomSplitBinningDefinition)
				{
					var _eBD:CustomSplitBinningDefinition = def as CustomSplitBinningDefinition;
					typeGroup.selection = ncRadio;
					csEditor.splitValues.text = _eBD.splitValues.value;
				}
				else if(def is QuantileBinningDefinition)
				{
					var _qb:QuantileBinningDefinition = def as QuantileBinningDefinition;
					typeGroup.selection = quantileRadio;
					refQuantile.text = _qb.refQuantile.value.toString();
				}
				else if(def is EqualIntervalBinningDefinition)
				{
					var _eiBD:EqualIntervalBinningDefinition = def as EqualIntervalBinningDefinition;
					typeGroup.selection = equalIntervalRadio;
					dataInterval.text = _eiBD.dataInterval.value.toString();
				}
				else if(def is StandardDeviationBinningDefinition)
				{
					var _sdBD:StandardDeviationBinningDefinition = def as StandardDeviationBinningDefinition;
					typeGroup.selection = sdRadio;
					SD.text = _sdBD.sdNumber.value.toString();
				}
				else if(def is CategoryBinningDefinition)
				{
					var _catBD:CategoryBinningDefinition = def as CategoryBinningDefinition;
					typeGroup.selection = catRadio;
				}
				
			
			}
			
			public function saveSessionState():void
			{
				binnedColumn.delayCallbacks();
				switch (typeGroup.selection)
				{
					case simpleRadio:
						var _sBD:SimpleBinningDefinition = binnedColumn.binningDefinition.requestLocalObject(SimpleBinningDefinition, false);
						_sBD.numberOfBins.value =  numOfBins.value;
						break;
					case ncRadio:
						var _eBD:CustomSplitBinningDefinition = binnedColumn.binningDefinition.requestLocalObject(CustomSplitBinningDefinition, false);
						_eBD.splitValues.value = csEditor.splitValues.text;
						break;
					case quantileRadio:
						var _qBD:QuantileBinningDefinition = binnedColumn.binningDefinition.requestLocalObject(QuantileBinningDefinition, false);
						_qBD.refQuantile.value = Number(refQuantile.text);
						break;
					case equalIntervalRadio:
						var _eiBD:EqualIntervalBinningDefinition = binnedColumn.binningDefinition.requestLocalObject(EqualIntervalBinningDefinition, false);
						_eiBD.dataInterval.value = Number(dataInterval.text);
						break;
					case sdRadio:
						var _sdBD:StandardDeviationBinningDefinition = binnedColumn.binningDefinition.requestLocalObject(StandardDeviationBinningDefinition, false);
						_sdBD.sdNumber.value = Number(SD.text);
						break;
					case catRadio:
						var _catBD:CategoryBinningDefinition = binnedColumn.binningDefinition.requestLocalObject(CategoryBinningDefinition, false);
						break;
					
				}
				binnedColumn.resumeCallbacks();
			}
			
			private function editNames():void
			{
				var binNameseditor:BinNamesEditor = new BinNamesEditor();
				
				//TODO:check if this right way to do!
				linkSessionState(binNameseditor.binnedColumn,binnedColumn);
				
				PopUpManager.addPopUp(binNameseditor as IFlexDisplayObject,this);
				
				binNameseditor.sendWindowToForeground();
			}
		]]>
	</mx:Script>
	

	</mx:VBox>