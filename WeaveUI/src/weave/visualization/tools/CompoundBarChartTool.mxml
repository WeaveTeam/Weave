<?xml version="1.0" encoding="utf-8"?>
<!--
/*
    Weave (Web-based Analysis and Visualization Environment)
    Copyright (C) 2008-2011 University of Massachusetts Lowell

    This file is a part of Weave.

    Weave is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License, Version 3,
    as published by the Free Software Foundation.

    Weave is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Weave.  If not, see <http://www.gnu.org/licenses/>.
*/
-->
<SimpleVisTool xmlns="weave.visualization.tools.*" 
	     xmlns:mx="http://www.adobe.com/2006/mxml"
	     xmlns:ui="weave.ui.*"
		 xmlns:userControls="weave.ui.userControls.*"
		 implements="weave.api.ui.IVisTool_Basic, weave.api.ui.IAltText"
	     layout="absolute" xmlns:settings="weave.ui.settings.*">
	<mx:Script>
		<![CDATA[
			import mx.core.mx_internal;
			
			import weave.Weave;
			import weave.api.copySessionState;
			import weave.api.core.ICallbackCollection;
			import weave.api.core.ILinkableHashMap;
			import weave.api.core.ILinkableObject;
			import weave.api.data.IAttributeColumn;
			import weave.api.data.IColumnStatistics;
			import weave.api.data.IQualifiedKey;
			import weave.api.getCallbackCollection;
			import weave.api.linkBindableProperty;
			import weave.api.linkSessionState;
			import weave.api.registerLinkableChild;
			import weave.api.setSessionState;
			import weave.api.ui.IPlotter;
			import weave.api.ui.IVisTool;
			import weave.api.unlinkSessionState;
			import weave.compiler.StandardLib;
			import weave.core.LinkableBoolean;
			import weave.core.LinkableNumber;
			import weave.core.LinkableVariable;
			import weave.core.UIUtils;
			import weave.data.StatisticsCache;
			import weave.primitives.ColorRamp;
			import weave.ui.AttributeSelectorPanel;
			import weave.ui.DynamicColumnComponent;
			import weave.ui.SelectableAttributesCheckBoxList;
			import weave.utils.BitmapText;
			import weave.utils.ColumnUtils;
			import weave.visualization.plotters.CompoundBarChartPlotter;
			import weave.visualization.plotters.SimpleAxisPlotter;

			WeaveAPI.ClassRegistry.registerImplementation(IVisTool, CompoundBarChartTool, "Bar Chart");

			/**
			 * When this is set to true, labels for all bars will be shown.
			 */
			public const showAllLabels:LinkableBoolean = registerLinkableChild(this, new LinkableBoolean(false));
			public const heightAxisTickCountRequested:LinkableNumber = registerLinkableChild(this, new LinkableNumber(5));
			public const heightAxisForceTickCount:LinkableBoolean = registerLinkableChild(this, new LinkableBoolean(false));
			public const linkHeightAndSortColumns:LinkableBoolean = registerLinkableChild(this, new LinkableBoolean(false), handleColumnLink, true);
			public const linkHeightAndColorColumns:LinkableBoolean = registerLinkableChild(this, new LinkableBoolean(false), handleColumnLink, true);
			
			private var _plotter:CompoundBarChartPlotter = null;
			private var _showYAxisLabels:Boolean = false;
			private var _showXAxisLabels:Boolean = false;

			override protected function inConstructor():void
			{
				super.inConstructor();

				// lock dynamic objects into place
				_plotter = initializePlotters(CompoundBarChartPlotter, true);
				_plotter.groupingMode.addImmediateCallback(this, updateAxisLabels);
				_plotter.horizontalMode.addImmediateCallback(this, updateAxisLabels);
				_plotter.showLabels.addImmediateCallback(this, updateAxisLabels);
				mainLayerSettings.hack_useTextBitmapFilters = true;
				
				initColumnLink(_plotter.colorColumn);
				initColumnLink(_plotter.sortColumn);
				initColumnLink(_plotter.heightColumns);
				
				var objects:Array = [
						xAxisPlotter,
						yAxisPlotter,
						visualization.plotManager.marginLeftNumber,
						visualization.plotManager.marginBottomNumber,
						visualization.plotManager.marginTopNumber,
						visualization.plotManager.marginRightNumber,
						_plotter
					];
				for each (var object:ILinkableObject in objects)
					getCallbackCollection(object).addGroupedCallback(this, updateAxisLabels, true);
				
				for each (var override:ILinkableObject in [
						visualization.plotManager.overrideXMin,
						visualization.plotManager.overrideYMin,
						visualization.plotManager.overrideXMax,
						visualization.plotManager.overrideYMax])
				{
					for each (var axisPlotter:IPlotter in [xAxisPlotter, yAxisPlotter])
						getCallbackCollection(override).addImmediateCallback(this, axisPlotter.spatialCallbacks.triggerCallbacks);
				}

				visualization.plotManager.marginBottom.value = "80";
				visualization.plotManager.marginLeft.value = "80";
				visualization.plotManager.marginTop.value = "30";
				visualization.plotManager.marginRight.value = "30";
				
				visualization.enableZoomAndPan.value = false;
				
				getCallbackCollection(plotter).addGroupedCallback(this, updateAltText, true);
				visualization.bottomMarginClickCallbacks.addImmediateCallback(this, function():void { handleAxisClick(true); });
				visualization.leftMarginClickCallbacks.addImmediateCallback(this, function():void { handleAxisClick(false); });
			}
			
			override public function initSelectableAttributes(input:Array):void
			{
				ColumnUtils.initSelectableAttributes([_plotter.sortColumn, _plotter.heightColumns], input);
			}
			
			public function get heightColumns():ILinkableHashMap { return _plotter.heightColumns; }
			public function get chartColors():ColorRamp { return _plotter.chartColors; }
			public function get colorIndicatesDirection():LinkableBoolean { return _plotter.colorIndicatesDirection; }
			
			public function get plotter():CompoundBarChartPlotter {return _plotter;}
			
			public const attributesToIncludeInProbe:LinkableVariable = registerLinkableChild(this, new LinkableVariable(Array, null, null), handleAttributesToIncludeInProbe, true);
			private function handleAttributesToIncludeInProbe():void
			{
				visualization.additionalProbeColumns = SelectableAttributesCheckBoxList.getSelectedAttributeColumns(this, attributesToIncludeInProbe);
			}
			[Deprecated] public function set includeToolAttributesInProbe(value:Boolean):void
			{
				attributesToIncludeInProbe.setSessionState(value ? getSelectableAttributeNames() : []);
			}
			
 			private function handleAxisClick(isXAxis:Boolean):void
			{
				if (isXAxis != _plotter.horizontalMode.value)
					AttributeSelectorPanel.open(_plotter.sortColumn);
				else
					AttributeSelectorPanel.open(_plotter.heightColumns);
			}
			
			override public function get defaultPanelTitle():String
			{
				var columns:Array = _plotter.heightColumns.getObjects(IAttributeColumn);
				for (var i:int = 0; i < columns.length; i++)
					columns[i] = ColumnUtils.getTitle(columns[i] as IAttributeColumn);
				return lang("Bar Chart of {0}", columns.join(lang(', ')));
			}
			
			private function updateAxisLabels():void
			{
				handlePanelTitleChange();
				
				var sortAxisTitle:String = lang("Sorted by {0}", ColumnUtils.getTitle(_plotter.sortColumn));
				var heightAxisTitle:String = '';
				var heightColumns:Array = _plotter.heightColumns.getObjects();
				for (var i:int = 0; i < heightColumns.length; i++)
				{
					if (i > 0)
						heightAxisTitle += lang(', ');
					heightAxisTitle += ColumnUtils.getTitle(heightColumns[i] as IAttributeColumn);
				}
				if (heightAxisTitle == '')
					heightAxisTitle = lang("Click to select...");

				var sortAxisToolTipColumn:IAttributeColumn = _plotter.sortColumn;
				var heightAxisToolTipColumn:IAttributeColumn = heightColumns.length > 0 ? heightColumns[0] : null;
				
				var sortAxis:SimpleAxisPlotter;
				var heightAxis:SimpleAxisPlotter;
				
				var xAxisTitle:String; // title for x axis, whether or not horizontal mode is on
				var yAxisTitle:String; // title for y axis, whether or not horizontal mode is on

				// BEGIN handling of horizontal/vertical mode ----------------------
				var _groupingMode:String = _plotter.getActualGroupingMode();
				if (_plotter.horizontalMode.value)
				{
					yAxisTitle = sortAxisTitle;
					sortAxis = yAxisPlotter;
					visualization.leftMarginColumn = sortAxisToolTipColumn;
									
					heightAxis = xAxisPlotter;
					xAxisTitle = heightAxisTitle;
					visualization.bottomMarginColumn = heightAxisToolTipColumn;
					
					visualization.enableProbeLine(_groupingMode == CompoundBarChartPlotter.STACK, false);
				}
				else
				{
					xAxisTitle = sortAxisTitle;
					sortAxis = xAxisPlotter;
					visualization.bottomMarginColumn = sortAxisToolTipColumn;
					
					yAxisTitle = heightAxisTitle;
					heightAxis = yAxisPlotter;
					visualization.leftMarginColumn = heightAxisToolTipColumn;
					
					visualization.enableProbeLine(false, _groupingMode == CompoundBarChartPlotter.STACK);
				}
				
				sortAxis.setLabelFunction(_plotter.sortAxisLabelFunction, _plotter.sortColumn);
				heightAxis.setLabelFunction(heightAxisLabelFunction, heightColumns[0]);
				
				unlinkSessionState(heightAxisForceTickCount, sortAxis.forceTickCount);
				unlinkSessionState(heightAxisTickCountRequested, sortAxis.tickCountRequested);
				unlinkSessionState(showAllLabels, heightAxis.forceTickCount);
				
				// height axis uses automatic min,max based on data
				heightAxis.tickMinValue.value = NaN;
				heightAxis.tickMaxValue.value = NaN;
				linkSessionState(heightAxisForceTickCount, heightAxis.forceTickCount);
				linkSessionState(heightAxisTickCountRequested, heightAxis.tickCountRequested);
				heightAxis.showLabels.value = true;

				// sort axis automatic min,max would be -0.5, numBars-0.5.  we don't want that.
				sortAxis.tickMinValue.value = 0;
				sortAxis.tickMaxValue.value = _plotter.maxTickMarks - 1;
				linkSessionState(showAllLabels, sortAxis.forceTickCount);
				if (showAllLabels.value)
					sortAxis.tickCountRequested.value = _plotter.maxTickMarks;
				else
					sortAxis.tickCountRequested.value = Math.min(_plotter.maxTickMarks, 11);
				sortAxis.showLabels.value = !_plotter.showLabels.value || showAllLabels.value;

				// END handling of horizontal/vertical mode --------------------------------
				
				xAxisPlotter.setSideAxisName(xAxisTitle, 0, 0, visualization.plotManager.marginBottomNumber.value - 3, BitmapText.VERTICAL_ALIGN_BOTTOM);
				yAxisPlotter.setSideAxisName(yAxisTitle, -90, -visualization.plotManager.marginLeftNumber.value, 0, BitmapText.VERTICAL_ALIGN_TOP);
			}
			
			private function heightAxisLabelFunction(value:Number):String
			{
				var _heightColumns:Array = _plotter.heightColumns.getObjects();
				if (_plotter.getActualGroupingMode() == CompoundBarChartPlotter.PERCENT_STACK && _heightColumns.length > 1)
					return lang("{0}%", StandardLib.roundSignificant(value));
				else if (_heightColumns.length > 0)
					return ColumnUtils.deriveStringFromNumber(_heightColumns[0], value); // always use the first column to format the axis labels
				return null;
			}
			
			private var _columnTriggerOrder:Dictionary = new Dictionary();
			private var _columnTriggerSerial:uint = 0;
			private function initColumnLink(target:ILinkableObject):void
			{
				var cc:ICallbackCollection = getCallbackCollection(target);
				cc.addImmediateCallback(this, function():void { _columnTriggerOrder[target] = ++_columnTriggerSerial; });
				cc.addGroupedCallback(this, handleColumnLink);
			}
			private function handleColumnLink():void
			{
				var linkColor:Boolean = linkHeightAndColorColumns.value;
				var linkSort:Boolean = linkHeightAndSortColumns.value;
				var colorSerial:int = _columnTriggerOrder[_plotter.colorColumn];
				var sortSerial:int = _columnTriggerOrder[_plotter.sortColumn];
				var heightSerial:int = _columnTriggerOrder[_plotter.heightColumns];
				
				if (linkColor && linkSort)
				{
					var latest:int = Math.max(colorSerial, sortSerial, heightSerial);
					if (heightSerial == latest)
						copyHeightToColorAndOrSort();
					else if (colorSerial == latest)
						copyColorToHeight();
					else if (sortSerial == latest)
						copySortToHeight();
				}
				else if (linkColor)
				{
					if (heightSerial > colorSerial)
						copyHeightToColorAndOrSort();
					else
						copyColorToHeight();
				}
				else if (linkSort)
				{
					if (heightSerial > sortSerial)
						copyHeightToColorAndOrSort();
					else
						copySortToHeight();
				}
			}
			
			private function copyColorToHeight():void
			{
				if (linkHeightAndColorColumns.value)
				{
					_plotter.heightColumns.delayCallbacks();
					
					ColumnUtils.forceFirstColumnDynamic(_plotter.heightColumns);
					var columns:Array = _plotter.heightColumns.getObjects();
					copySessionState(ColumnUtils.hack_findInternalDynamicColumn(_plotter.colorColumn), columns[0]);
					
					_plotter.heightColumns.resumeCallbacks();
				}
			}
			
			private function copySortToHeight():void
			{
				if (!_plotter.sortColumn.getInternalColumn())
					return;
				
				if (linkHeightAndSortColumns.value)
				{
					_plotter.heightColumns.delayCallbacks();
					
					ColumnUtils.forceFirstColumnDynamic(_plotter.heightColumns);
					var columns:Array = _plotter.heightColumns.getObjects();
					copySessionState(_plotter.sortColumn, columns[0]);
					
					_plotter.heightColumns.resumeCallbacks();
				}
			}
			
			private function copyHeightToColorAndOrSort():void
			{
				if (_plotter.heightColumns.getObjects().length < 1)
					return;

				var columns:Array;
				if (linkHeightAndColorColumns.value)
				{
					_plotter.heightColumns.delayCallbacks();
					
					ColumnUtils.forceFirstColumnDynamic(_plotter.heightColumns);
					columns = _plotter.heightColumns.getObjects();
					copySessionState(columns[0], ColumnUtils.hack_findInternalDynamicColumn(_plotter.colorColumn));
					
					_plotter.heightColumns.resumeCallbacks();
				}
				if (linkHeightAndSortColumns.value)
				{
					_plotter.heightColumns.delayCallbacks();
					
					ColumnUtils.forceFirstColumnDynamic(_plotter.heightColumns);
					columns = _plotter.heightColumns.getObjects();
					copySessionState(columns[0], _plotter.sortColumn);
					
					_plotter.heightColumns.resumeCallbacks();
				}
			}
			
			public function createLegend():void
			{
				var barChartLegendTool:BarChartLegendTool = Weave.root.requestObject(null, BarChartLegendTool, false);
				barChartLegendTool.dynamicBarChartTool.globalName = Weave.root.getName(this);
			}
			
			public function updateAltText():void
			{
				var temp:String = lang("Bar Chart showing ");
				
				for(var i:int; i < _plotter.heightColumns.getObjects().length; i++)
				{
					temp += ColumnUtils.getTitle(_plotter.heightColumns.getObjects()[i] as IAttributeColumn) + ", ";
				}
				
				temp += "sorted by ";
				
				temp += ColumnUtils.getTitle(_plotter.sortColumn);
				
				temp += '\n';
				
				var heights:Array = _plotter.heightColumns.getObjects();
				if(heights.length == 1)
				{
					var heightColumn:IAttributeColumn = heights[0] as IAttributeColumn;
					var statsHeight:IColumnStatistics = WeaveAPI.StatisticsCache.getColumnStatistics(heightColumn);
					var max:Number = statsHeight.getMax();
					var min:Number = statsHeight.getMin();
					
					var max_keys:Array = [];
					var min_keys:Array = [];
					
					for each (var k:IQualifiedKey in heightColumn.keys)
					{
						if(heightColumn.getValueFromKey(k) == max)
							max_keys.push(k);
						if(heightColumn.getValueFromKey(k) == min)
							min_keys.push(k);
						
					}
					temp += lang("The maximum {0} is {1} when {2} is", ColumnUtils.getTitle(heightColumn), max, ColumnUtils.getTitle(_plotter.sortColumn));
					
					for each(k in max_keys)
					{
						temp += " " + _plotter.sortColumn.getValueFromKey(k);
					}
					
					temp += ".";
					temp += '\n';
					
					temp += lang("The minimum {0} is {0} when {1} is", ColumnUtils.getTitle(heightColumn), min, ColumnUtils.getTitle(_plotter.sortColumn));
					
					for each(k in min_keys)
					{
						temp += " " + _plotter.sortColumn.getValueFromKey(k);
					}
					
					temp += ".";
				}
				altTextEditor.automaticDescription.value = temp;
				getCallbackCollection(this).triggerCallbacks();
			}
			
			// backwards compatibility
			[Deprecated] public function set labelColumn(value:Object):void { setSessionState(_plotter.labelColumn, value); }
			[Deprecated] public function set sizeAxisTickCountRequested(value:Number):void { heightAxisTickCountRequested.value = value; }
		]]>
	</mx:Script>
	<editorFactory><mx:Component><ui:ControlPanel>
		<mx:VBox id="attributesPanel" label="{lang('Basic')}">
			<ui:DynamicColumnComponent id="colorColumnInput" label="{lang('Color')}" creationComplete="(event.target as DynamicColumnComponent).columnWrapper = _plotter.colorColumn"
									   toolTip="{lang('Color column selection is enabled when only a single column is in the list below.')}" showLinkControl="false"/>
			<ui:DynamicColumnComponent label="{lang('Label')}" creationComplete="(event.target as DynamicColumnComponent).dynamicObject = _plotter.labelColumn"/>
			<ui:DynamicColumnComponent label="{lang('Sort')}" creationComplete="(event.target as DynamicColumnComponent).dynamicObject = _plotter.sortColumn"/>
			<ui:CustomCheckBox id="groupBySortColumnCheckBox" label="{lang('Group bars by the sort column')}" creationComplete="linkBindableProperty(_plotter.groupBySortColumn, event.target, 'selected');"/>
			<mx:HBox>
				<ui:CustomCheckBox id="horizontalCheckBox" label="{lang('Horizontal bars')}"
							 toolTip="{lang('Check this box to display the bars horizontally, with values setting the length of the bar (from left to right) rather than the height (from bottom to top).')}"/>
				<mx:RadioButtonGroup id="groupMode"/>
				<mx:RadioButton id="groupedRadioButton" groupName="groupMode" label="{lang('Grouped bars')}" value="{CompoundBarChartPlotter.GROUP}"/>
				<mx:RadioButton id="stackedRadioButton" groupName="groupMode" label="{lang('Stacked bars')}" value="{CompoundBarChartPlotter.STACK}"/>
				<mx:RadioButton id="percentStackedRadioButton" groupName="groupMode" label="{lang('100% Stacked bars')}" value="{CompoundBarChartPlotter.PERCENT_STACK}"/>
			</mx:HBox>
			<ui:CustomTabNavigator creationPolicy="all" initialize="UIUtils.pad(event, 5, 100, 100)">
				<ui:ColumnListComponent creationComplete="(event.target as ColumnListComponent).hashMap = _plotter.heightColumns"/>
				<ui:ColumnListComponent creationComplete="(event.target as ColumnListComponent).hashMap = _plotter.positiveErrorColumns"/>
				<ui:ColumnListComponent creationComplete="(event.target as ColumnListComponent).hashMap = _plotter.negativeErrorColumns"/>
			</ui:CustomTabNavigator>
			<mx:HBox>
				<ui:CustomCheckBox label="{lang('Link Height and Sort Column')}" creationComplete="linkBindableProperty(outerDocument.linkHeightAndSortColumns, event.target, 'selected');"/>
				<ui:CustomCheckBox label="{lang('Link Height and Color Column')}" creationComplete="linkBindableProperty(outerDocument.linkHeightAndColorColumns, event.target, 'selected');"/>
			</mx:HBox>
		</mx:VBox>
		<mx:VBox label="{lang('Labeling')}">
			<mx:Button label="{lang('Show legend')}" click="outerDocument.createLegend()"/>
			<ui:CustomCheckBox label="{lang('Show all axis labels')}" creationComplete="linkBindableProperty(outerDocument.showAllLabels, event.target, 'selected');"/>
			<mx:HBox width="100%">
				<mx:VBox width="100%">
					<ui:CustomCheckBox label="{lang('Show bar labels')}" id="labelsChkBx"
								 creationComplete="linkBindableProperty(_plotter.showLabels, event.target, 'selected')"/>
					<mx:VBox paddingLeft="24" enabled="{labelsChkBx.selected}" width="100%">
						<mx:HBox>
							<ui:CustomCheckBox id="colorRecordLabelsChk" label="{lang('Color by record')}"
										 creationComplete="linkBindableProperty(_plotter.recordLabelColoring, event.target, 'selected')"/>
							<ui:HelpComponent>
								This specifies if each label should have the same color as its corresponding record.
							</ui:HelpComponent>
							<mx:Spacer width="100%"/>
							<mx:HBox id="colorRecordLabelsBox" enabled="{!colorRecordLabelsChk.selected}">
								<mx:Label text="{lang('Color')}"/>
								<ui:CustomColorPicker creationComplete="linkBindableProperty(_plotter.labelColor, event.target, 'selectedColor');"/>
								<ui:HelpComponent>
									This specifies the color to use for every label.
								</ui:HelpComponent>
							</mx:HBox>
						</mx:HBox>
						<mx:HBox>
							<mx:VBox>
								<ui:IndentTextInput inputWidth="64" label="{lang('Position')}" creationComplete="linkBindableProperty(_plotter.labelDataCoordinate, event.target, 'text')"/>
								<ui:Indent label="{lang('Angle')}">
									<mx:NumericStepper minimum="-180" maximum="180" stepSize="15" width="64"
											creationComplete="linkBindableProperty(_plotter.labelRelativeAngle, event.target, 'value')"/>
								</ui:Indent>
								<ui:Indent label="{lang('Max width')}">
									<mx:NumericStepper minimum="5" maximum="1000" stepSize="5" width="64"
											creationComplete="linkBindableProperty(_plotter.labelMaxWidth, event.target, 'value')"/>
								</ui:Indent>
							</mx:VBox>
							<ui:AlignmentControl creationComplete="linkBindableProperty(_plotter.labelVerticalAlign, event.target, 'verticalAlign'); linkBindableProperty(_plotter.labelHorizontalAlign, event.target, 'horizontalAlign');"/>
						</mx:HBox>
						<mx:Label text="{lang('Label formatter:')}"/>
						<mx:Box paddingLeft="24">
							<mx:TextArea width="100%" height="100%" creationComplete="linkBindableProperty(_plotter.labelFormatter, event.target, 'text');"/>
						</mx:Box>
					</mx:VBox>
				</mx:VBox>
				<mx:Spacer width="100%"/>
				<mx:VBox width="100%">
					<ui:CustomCheckBox id="showValueLabelsCheckBox" label="{lang('Show value labels')}" change="showValueLabelsCheckBox_changeHandler()"/>
					<mx:VBox paddingLeft="24" enabled="{showValueLabelsCheckBox.selected}" width="100%">
						<mx:HBox>
							<ui:CustomCheckBox id="colorValueLabelsChk" label="{lang('Color by record')}"
										 creationComplete="linkBindableProperty(_plotter.recordValueLabelColoring, event.target, 'selected')"/>
							<ui:HelpComponent>This specifies if each label should have the same color as its corresponding record.</ui:HelpComponent>
							<mx:Spacer width="100%"/>
							<mx:HBox id="colorValueLabelColorBox" enabled="{!colorValueLabelsChk.selected}">
								<mx:Label text="{lang('Color')}"/>
								<ui:CustomColorPicker id="valueLabelColorPicker" creationComplete="linkBindableProperty(_plotter.valueLabelColor, event.target, 'selectedColor');"/>
								<ui:HelpComponent>
									This specifies the color to use for every label.
								</ui:HelpComponent>
							</mx:HBox>
						</mx:HBox>
						<mx:HBox>
							<mx:VBox>
								<ui:IndentTextInput inputWidth="64" label="{lang('Position')}" creationComplete="linkBindableProperty(_plotter.valueLabelDataCoordinate, event.target, 'text')"/>
								<ui:Indent label="{lang('Angle')}">
									<mx:NumericStepper minimum="-180" maximum="180" stepSize="15" width="64"
											creationComplete="linkBindableProperty(_plotter.valueLabelRelativeAngle, event.target, 'value')"/>
								</ui:Indent>
								<ui:Indent label="{lang('Max width')}">
									<mx:NumericStepper minimum="5" maximum="1000" stepSize="5" width="64"
											creationComplete="linkBindableProperty(_plotter.valueLabelMaxWidth, event.target, 'value')"/>
								</ui:Indent>
							</mx:VBox>
							<ui:AlignmentControl creationComplete="linkBindableProperty(_plotter.valueLabelVerticalAlign, event.target, 'verticalAlign'); linkBindableProperty(_plotter.valueLabelHorizontalAlign, event.target, 'horizontalAlign');"/>
						</mx:HBox>
					</mx:VBox>
				</mx:VBox>
			</mx:HBox>
		</mx:VBox>
		
		<mx:VBox id="advControlsPanel" label="{lang('Advanced')}">
			<ui:CustomCheckBox label="{lang('Draw outlines on bars')}" creationComplete="linkBindableProperty(_plotter.line.enable, event.target, 'selected');"/>
			<ui:CustomCheckBox label="{lang('In stacked mode, use gaps for missing data')}" creationComplete="linkBindableProperty(_plotter.stackedMissingDataGap, event.target, 'selected');"/>
			<ui:Indent label="{lang('Bar spacing:')}">
				<mx:HSlider id="barSpacingSlider" value="0" minimum="0" maximum="1" labels="{[lang('No gap'), lang('1:3'), lang('1:1')]}" tickInterval="0.25"
							toolTip="{lang('Move this slider to change the gap between bars.  All the way to the left means no gap.  The highest value is a 1:1 ratio, meaning equal bar width to gap width.')}" showDataTip="false"
							liveDragging="true"/>
			</ui:Indent>
			
			<ui:CustomCheckBox label="{lang('Zoom to subset (height)')}"
							   toolTip="{lang('Enables automatic zooming to the subset of height data currently displayed')}"
							   creationComplete="linkBindableProperty(_plotter.zoomToSubset, event.target, 'selected')"/>
			<ui:CustomCheckBox label="{lang('Zoom to subset (bars)')}"
							   toolTip="{lang('Enables automatic zooming to the subset of bars currently displayed')}"
						 	   creationComplete="linkBindableProperty(_plotter.zoomToSubsetBars, event.target, 'selected')"/>
			<ui:CustomCheckBox label="{lang('Use color to indicate positive or negative value')}"
							   creationComplete="linkBindableProperty(_plotter.colorIndicatesDirection, event.target, 'selected')"/>
			<ui:ColorRampEditor id="cRampEditor" toolTip="{lang('The color ramp can only be set when more than one height column is specified.')}"/>
		</mx:VBox>
		<mx:VBox label="{lang('Mouseover info')}">
			<ui:SelectableAttributesCheckBoxList id="selectedAttrList" creationComplete="selectedAttrList.setup(outerDocument, outerDocument.attributesToIncludeInProbe)"/>
		</mx:VBox>
		<mx:Script>
			<![CDATA[
				import weave.api.getCallbackCollection;
				import weave.api.linkBindableProperty;
				import weave.core.UIUtils;
				import weave.utils.BitmapText;
				import weave.visualization.plotters.CompoundBarChartPlotter;
				
				private function get _plotter():CompoundBarChartPlotter { return outerDocument.plotter; }
				
				override protected function childrenCreated():void
				{
					super.childrenCreated();
					
					cRampEditor.colorRamp = _plotter.chartColors;
					linkBindableProperty(_plotter.horizontalMode, horizontalCheckBox, "selected");
					linkBindableProperty(_plotter.barSpacing, barSpacingSlider, "value");
					linkBindableProperty(_plotter.showValueLabels, showValueLabelsCheckBox, "selected");
					linkBindableProperty(_plotter.groupingMode, groupMode, 'selectedValue', 0); // this must be done after creationComplete because the RadioButtonGroup hasn't been initialized until then.
					_plotter.groupingMode.addGroupedCallback(this, updateInteractivity, true);
					_plotter.groupBySortColumn.addGroupedCallback(this, updateInteractivity, true);
					getCallbackCollection(_plotter.heightColumns).addGroupedCallback(this, updateInteractivity, true);
					getCallbackCollection(_plotter.colorIndicatesDirection).addGroupedCallback(this, updateInteractivity, true);
				}

				private function updateInteractivity():void
				{
					if (!parent)
						return callLater(updateInteractivity);
					var _heightColumns:Array = _plotter.heightColumns.getObjects();
					
					if (_heightColumns.length > 1)
					{
						cRampEditor.enabled = true;
						groupMode.enabled = true;
						colorColumnInput.enabled = false;
					}
					else
					{
						cRampEditor.enabled = false || _plotter.colorIndicatesDirection.value;
						groupMode.enabled = false;
						colorColumnInput.enabled = true;
					}
				}
				
				private function showValueLabelsCheckBox_changeHandler():void
				{
					if (showValueLabelsCheckBox.selected)
					{
						if ((stackedRadioButton.enabled && stackedRadioButton.selected)|| (percentStackedRadioButton.enabled && percentStackedRadioButton.selected))
							_plotter.valueLabelHorizontalAlign.value = BitmapText.HORIZONTAL_ALIGN_CENTER;
						else
							_plotter.valueLabelHorizontalAlign.value = BitmapText.HORIZONTAL_ALIGN_LEFT;
					}
				}
			]]>
		</mx:Script>
	</ui:ControlPanel></mx:Component></editorFactory>
</SimpleVisTool>
