<?xml version="1.0" encoding="utf-8"?>
<!--
/*
Weave (Web-based Analysis and Visualization Environment)
Copyright (C) 2008-2011 University of Massachusetts Lowell

This file is a part of Weave.

Weave is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License, Version 3,
as published by the Free Software Foundation.

Weave is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Weave.  If not, see <http://www.gnu.org/licenses/>.
*/
-->
<!---
@author kmanohar
@author spurushe
-->
<SimpleVisTool xmlns="weave.visualization.tools.*" 
			   xmlns:mx="http://www.adobe.com/2006/mxml"
			   xmlns:ui="weave.ui.*" 
			   xmlns:userControls="weave.ui.userControls.*"		 
			   layout="absolute"
			  >
	<mx:Script>
		<![CDATA[
			import mx.rpc.events.FaultEvent;
			import mx.rpc.events.ResultEvent;
			
			import spark.core.SpriteVisualElement;
			
			import weave.Weave;
			import weave.api.core.ICallbackCollection;
			import weave.api.data.IAttributeColumn;
			import weave.api.data.IKeySet;
			import weave.api.data.IQualifiedKey;
			import weave.api.disposeObject;
			import weave.api.getCallbackCollection;
			import weave.api.newDisposableChild;
			import weave.api.newLinkableChild;
			import weave.api.registerLinkableChild;
			import weave.api.reportError;
			import weave.api.ui.IVisTool;
			import weave.core.CallbackCollection;
			import weave.core.LinkableBoolean;
			import weave.core.LinkableString;
			import weave.data.AttributeColumns.DynamicColumn;
			import weave.data.AttributeColumns.NumberColumn;
			import weave.data.KeySets.KeySet;
			import weave.primitives.Bounds2D;
			import weave.primitives.ColorRamp;
			import weave.radviz.ClassDiscriminationLayoutAlgorithm;
			import weave.services.WeaveRServlet;
			import weave.services.addAsyncResponder;
			import weave.ui.DraggablePanel;
			import weave.utils.ColumnUtils;
			import weave.utils.ResultUtils;
			import weave.visualization.plotters.AnchorPlotter;
			import weave.visualization.plotters.AnchorPoint;
			import weave.visualization.plotters.RadVizPlotter;
			
			WeaveAPI.ClassRegistry.registerImplementation(IVisTool, RadVizTool, "RadViz");
			
			[Bindable]
			public var _plotter:RadVizPlotter ;
			public var _anchorPlotter:AnchorPlotter ;
			
			private static const ANCHOR_LAYER:String = "anchorLayer";
			
			public var normalizedColumns:Array = new Array();//normalized columns returned from R
			private var normalizedColumnsGroup:ICallbackCollection; // linkable object used to group norm columns and check busy status
			public const classDiscriminatorColumn:DynamicColumn = newLinkableChild(this, DynamicColumn, classDiscriminatorColumnUpdate);//column used as the Class Discriminator
			public var cdLayout:ClassDiscriminationLayoutAlgorithm = new ClassDiscriminationLayoutAlgorithm();
			private var Rservice:WeaveRServlet = new WeaveRServlet(Weave.properties.rServiceURL.value);
			
			public var latestjoinedColumnKeys:Array = new Array();
			
			public const enableProbeLines:LinkableBoolean = registerLinkableChild(this,new LinkableBoolean(false));
			public const enabelAnnuliCircles:LinkableBoolean = registerLinkableChild(this, new LinkableBoolean(true));
			
			override protected function inConstructor():void
			{
				super.inConstructor();
				
				// lock dynamic objects into place
				_plotter = initializePlotters(RadVizPlotter, false);
				getCallbackCollection(_plotter).addGroupedCallback(this, handlePlotterChanges);
				
				visualization.plotManager.enableAutoZoomToExtent.value = true;
				visualization.plotManager.enableFixedAspectRatio.value = true;
				visualization.enableZoomAndPan.value = false;
				
				_plotter.setAnchorLocations();//normal layout
				_anchorPlotter = visualization.plotManager.plotters.requestObject(ANCHOR_LAYER, AnchorPlotter, true) ;
				visualization.plotManager.getLayerSettings(ANCHOR_LAYER).selectable.value = false;
				_anchorPlotter.setRadViz(_plotter);
				
				getCallbackCollection(mainLayerSettings.probeFilter).addImmediateCallback(this,drawProbeLines);
				getCallbackCollection(mainLayerSettings.probeFilter).addImmediateCallback(this,drawAnnuliCircles);
				
				visualization.plotManager.marginTop.value =	visualization.plotManager.marginBottom.value = "20";
				visualization.plotManager.marginLeft.value = visualization.plotManager.marginRight.value = "20";				
			}
			
			override public function initSelectableAttributes(input:Array):void
			{
				input.slice(0,10).forEach(function(item:Object, i:int, a:Array):void {
					ColumnUtils.initSelectableAttribute(_plotter.columns, item, i == 0);
				});
			}
			
			override protected function childrenCreated():void
			{
				super.childrenCreated();
				
				_plotter.columns.addGroupedCallback(this, normalizationInR);
				classDiscriminatorColumn.addImmediateCallback(this, classDiscriminatorColumnUpdate,true);
				
				probeSprite.mouseChildren = false;
				selectionProbeSprite.mouseChildren = false;
				anchorProbeSprite.mouseChildren = false;
				//visualization.rawChildren.addChild(probeSprite);
				var sprCont:SpriteVisualElement = new SpriteVisualElement();
				sprCont.addChild(probeSprite);
				sprCont.addChild(selectionProbeSprite);
				sprCont.addChild(anchorProbeSprite);
				visualization.addElement(sprCont);
				
				visualization.addEventListener(MouseEvent.MOUSE_DOWN, handleMouseDown, true);
				WeaveAPI.StageUtils.addEventCallback(MouseEvent.MOUSE_MOVE, this, handleMouseMove);
				WeaveAPI.StageUtils.addEventCallback(MouseEvent.MOUSE_UP, this, handleMouseUp);
				
				_selection.addGroupedCallback(this,drawProbeLinesForSelectionKeySet);
			}
			
			private var tempBounds:Bounds2D = new Bounds2D();
			private var screenBounds:Bounds2D = new Bounds2D();			
			private var tempPoint:Point = new Point();					
			
			private var _probedKeys:Array ;
			private var _probedAnchor:AnchorPoint;
			private var dataBounds:Bounds2D = new Bounds2D();
			private var isDragging:Boolean = false;			
			private var enableAutoZoom:Boolean;
			
			private var probeSprite:Sprite = new Sprite() ;	
			private var selectionProbeSprite:Sprite = new Sprite();
			private var anchorProbeSprite:Sprite = new Sprite();
			
			//this function is called whenver a column is selected to do the class discrimination
			private function classDiscriminatorColumnUpdate():void
			{
				
				var colObjects:Array = _plotter.columns.getObjects();//user selected columns
				//the class discriminator column needs to be selected and the columns need to be normalized
				if(classDiscriminatorColumn.keys.length == 0 || colObjects.length == 0 ||
					WeaveAPI.SessionManager.linkableObjectIsBusy(normalizedColumnsGroup) ||
					!normalizedColumnsGroup)//incase user selects discriminator before columns
				{return;}
				
				//populates the data structure on which the CD algorithm is then run
				cdLayout.fillingClassToColumnMap(classDiscriminatorColumn,colObjects,_plotter.columns.getNames(),normalizedColumns);
				
				
			}
			
			override protected function updateDisplayList(unscaledWidth:Number, unscaledHeight:Number):void
			{
				super.updateDisplayList(unscaledWidth,unscaledHeight);
				drawProbeLinesForSelectionKeySet();
				drawProbeLinesForSelectedAnchor();
			}
			
			private function handlePlotterChanges():void
			{
				handlePanelTitleChange();
				
				drawProbeLinesForSelectionKeySet();
			}
			
			//returns two columns with common keys
			private function joinColumns(columns:Array):Array
			{
				var selection:KeySet = Weave.defaultSelectionKeySet;
				var keys:Array = selection.keys.length > 0 ? selection.keys : null;
				var result:Array = ColumnUtils.joinColumns(columns, Number, false, keys);
				return [result.shift(), result];
			}
			
			/**this function sends the data in the form of a matrix for normalization in R*
			 * Used for Class discrimination Layout algorithm*/
			private function normalizationInR():void
			{
				if (WeaveAPI.SessionManager.linkableObjectIsBusy(_plotter.columns))//do the next chunk of code only after _plotter.columns is filled
					return;
				
				var columns:Array = _plotter.columns.getObjects();
				var result:Array = joinColumns(columns);
				latestjoinedColumnKeys = result[0];
				var joinedColumns:Array = result[1];
				
				if (latestjoinedColumnKeys.length > 0)
				{
					addAsyncResponder(
						Rservice.normalize(joinedColumns),
						handleNormScriptResult,
						handleRunScriptFault,
						latestjoinedColumnKeys
					);
				}
			} 
			
			
			
			/** Returns the normalized dataset */
			private function handleNormScriptResult(event:ResultEvent, token:Object = null):void
			{
				normalizedColumns = [];
				if (token != latestjoinedColumnKeys){return;}//handles two asynchronous calls made one after the other
				
				//Object to store returned result
				var result:Array = event.result as Array;				
				
				disposeObject(normalizedColumnsGroup);
				normalizedColumnsGroup = newDisposableChild(this, CallbackCollection);
				if(result)
				{
					for (var j:int = 0; j < result.length; j++)
					{
						var col:NumberColumn = ResultUtils.resultAsNumberColumn(token,result[j],_plotter.columns.getNames()[j]+" norm");
						normalizedColumns.push(col);
						registerLinkableChild(normalizedColumnsGroup, col);
					}
				}
				//normalizedColumnsGroup.addImmediateCallback(this, classDiscriminatorColumnUpdate);
			}
			
			private function handleRunScriptFault(event:FaultEvent, token:Object = null):void
			{
				trace(["fault", token, event.message].join('\n'));
				// do not report this error since normalization will fall back on actionscript side.
				// reportError(event); 
			}
			
			private var _selection:KeySet = Weave.root.getObject(Weave.DEFAULT_SELECTION_KEYSET) as KeySet;
			private function drawProbeLinesForSelectionKeySet():void
			{
				if(!Weave.properties.enableProbeLines.value || !enableProbeLines.value) return;
				
				visualization.plotManager.zoomBounds.getDataBounds(dataBounds);
				visualization.plotManager.zoomBounds.getScreenBounds(screenBounds);
				_plotter.drawProbe = true;
				_plotter.drawProbeLines(_selection.keys,dataBounds,screenBounds,selectionProbeSprite.graphics);			
			}
			
			private function drawProbeLines():void
			{ 
				if(!Weave.properties.enableProbeLines.value || !enableProbeLines.value) return;
				
				var probeKeySet:IKeySet = (mainLayerSettings.probeFilter.internalObject) as IKeySet;
				if (!probeKeySet)
					return;
				
				visualization.plotManager.zoomBounds.getDataBounds(dataBounds);
				visualization.plotManager.zoomBounds.getScreenBounds(screenBounds);
				
				_plotter.drawProbe = (this as DraggablePanel) == DraggablePanel.activePanel;
				
				_plotter.drawProbeLines(probeKeySet.keys,dataBounds, screenBounds, probeSprite.graphics);	
				
			}
			private function drawAnnuliCirclesForSelectionKeySet():void
			{
				if(!enabelAnnuliCircles.value) return;
				var probeKeySet:IKeySet = (mainLayerSettings.probeFilter.internalObject) as IKeySet;
				if (!probeKeySet)
					return;
				
				visualization.plotManager.zoomBounds.getDataBounds(dataBounds);
				visualization.plotManager.zoomBounds.getScreenBounds(screenBounds);
				
				_plotter.drawAnnuli = (this as DraggablePanel) == DraggablePanel.activePanel;
				
				_plotter.drawAnnuliCircles(probeKeySet.keys,dataBounds, screenBounds, probeSprite.graphics);
				
			}
			public function drawAnnuliCircles():void
			{
				_plotter.drawProbe = false;
				
				var probeKeySet:IKeySet = (mainLayerSettings.probeFilter.internalObject) as IKeySet;
				if (!probeKeySet)
					return;	
				
				visualization.plotManager.zoomBounds.getDataBounds(dataBounds);
				visualization.plotManager.zoomBounds.getScreenBounds(screenBounds);
				
				_plotter.drawAnnuli = (this as DraggablePanel) == DraggablePanel.activePanel;
				_plotter.drawAnnuliCircles(probeKeySet.keys, dataBounds, screenBounds, probeSprite.graphics);
					
			}
			
			private function handleMouseDown(event:MouseEvent):void
			{
				tempPoint = visualization.globalToLocal(new Point(event.stageX,event.stageY));
				tempBounds.reset();
				tempBounds.setCenter(tempPoint.x, tempPoint.y);
				tempBounds.centeredResize(20,20);
				
				visualization.plotManager.zoomBounds.getDataBounds(dataBounds);
				visualization.plotManager.zoomBounds.getScreenBounds(screenBounds);
				screenBounds.projectCoordsTo(tempBounds, dataBounds);
				
				_probedKeys = visualization.plotManager.hack_getSpatialIndex(ANCHOR_LAYER).getKeysBoundingBoxOverlap(tempBounds);
				if (!_probedKeys.length)
				{
					anchorProbeSprite.graphics.clear();					
					return;
				}
				event.stopPropagation();
				
				var key:IQualifiedKey = _probedKeys[0];
				_probedAnchor = _plotter.anchors.getObject(key.localName) as AnchorPoint;													
				 
				visualization.enableSelection.value = false;
				enableAutoZoom = visualization.plotManager.enableAutoZoomToExtent.value;
				visualization.plotManager.enableAutoZoomToExtent.value = false;
				isDragging = true;
				anchorProbeSprite.graphics.clear();
			}
			
			private function drawProbeLinesForSelectedAnchor():void
			{
				if(_probedKeys && _probedKeys.length)
					_plotter.drawProbeLinesForSelectedAnchors(_probedKeys,dataBounds,screenBounds,anchorProbeSprite.graphics);
				else
					anchorProbeSprite.graphics.clear();
			}
			
			private function handleMouseUp():void
			{
				if (!isDragging)
					return;
				drawProbeLinesForSelectedAnchor();
				handleMouseMove();
				_probedAnchor = null;
				isDragging = false;
				visualization.enableSelection.value = true;
				visualization.plotManager.enableAutoZoomToExtent.value = enableAutoZoom;
			}
			
			private function handleMouseMove():void
			{
				if (!isDragging || !_probedAnchor)
					return;
				var event:MouseEvent = WeaveAPI.StageUtils.mouseEvent;
				tempPoint = visualization.globalToLocal(new Point(event.stageX, event.stageY));
				
				screenBounds.projectPointTo(tempPoint, dataBounds);
				_probedAnchor.x.value = tempPoint.x;
				_probedAnchor.y.value = tempPoint.y;
				
				var theta:Number = _probedAnchor.polarRadians.value;
				
				if(_anchorPlotter.unrestrictAnchors.value)
					return;
				_probedAnchor.x.value = Math.cos(theta);
				_probedAnchor.y.value = Math.sin(theta);
			}
			
			override public function getSelectableAttributeNames():Array
			{
				return super.getSelectableAttributeNames().concat(['Class Descriminator']);
			}
			
			override public function getSelectableAttributes():Array
			{
				return super.getSelectableAttributes().concat([classDiscriminatorColumn]);
			}
			
			override public function get defaultPanelTitle():String
			{
				var columns:Array = _plotter.columns.getObjects(IAttributeColumn);
				for (var i:int = 0; i < columns.length; i++)
					columns[i] = ColumnUtils.getTitle(columns[i] as IAttributeColumn);
				return lang("RadViz of {0}", columns.join(lang(', ')));
			}
			
			private const colorRampName:LinkableString = newLinkableChild(this, LinkableString,handleColorRampName);
			
			private function handleColorRampName():void
			{
				if (stage == null)
					return callLater(handleColorRampName);
				_plotter.colorMap.value = ColorRamp.getColorRampXMLByName(colorRampName.value);				
			}
		]]>
	</mx:Script>
</SimpleVisTool>
