<?xml version="1.0" encoding="utf-8"?>
<s:NavigatorContent xmlns:fx="http://ns.adobe.com/mxml/2009" 
 xmlns:s="library://ns.adobe.com/flex/spark"  creationPolicy="all"
 xmlns:mx="library://ns.adobe.com/flex/mx" width="500" height="600" implements="weave.api.ui.ILinkableObjectEditor" xmlns:ui="weave.ui.*" xmlns="weave.editors.*">
	<s:layout>
		<s:VerticalLayout/>
	</s:layout>
	<ui:DynamicColumnComponent id="geometryComponent" label="{lang('Geometry')}"/>
	<s:BorderContainer borderStyle="solid"  width="100%">
		<s:layout>
			<s:VerticalLayout gap="0"  paddingLeft="1" paddingBottom="1" paddingRight="1" paddingTop="1" />
		</s:layout>
		<s:CheckBox id="fillEnabled" label="{lang('Enable Fill Color')}" fontWeight="bold"
					 toolTip="{lang('Check this box to enable the color used inside each shape.\nThis would typically be unchecked if the shapes are to be used for borders only, such as overlaying state borders over colored in municipalities.')}"
					 creationComplete="linkBindableProperty(_plotter.fill.enabled.defaultValue,event.target,'selected')"/>
		
		<s:HGroup verticalAlign="middle" >
			<s:VGroup enabled="{fillEnabled.selected}" gap="0">
				<s:Label text="{lang('Alpha:')}"/>
				<mx:NumericStepper 	id="fillAlpha" 
									minimum="0" maximum="1" stepSize="0.1" 
									value="0"
									width="50"
									toolTip="{lang('Set the alpha (0: transparent, 1: opaque) of the color inside each shape.')}"
									creationComplete="linkBindableProperty(_plotter.fill.alpha.defaultValue,event.target,'value')"/>
				
			</s:VGroup>
			
			<s:VGroup enabled="{fillEnabled.selected}" gap="0" horizontalAlign="center">
				<s:Label text="{lang('Default color:')}"/>
				<s:HGroup>
					<s:CheckBox id="enableDefaultColor" label="" 
								 change="handleSolidFillColorCheck()"
								 toolTip="{lang('Check this box to allow choosing a color that will be used either when there is missing data when data is mapped to the color, or as the color for all shapes when no data is mapped.\nThis would typically be checked when a single color is desired for all shapes (no data mapped to color), or when the missing data is to be shown as a solid color rather than the default pattern.')}"/>
					<mx:ColorPicker id="fillColor"
									enabled="{enableDefaultColor.selected}"
									change="handleFillColorSelected()"
									selectedColor="0xFFFFFF"
									toolTip="{lang('Set the color to fill in the shape when there is no data mapped to the shapes or when there is missing data when data is being mapped to the shapes.')}" />
				</s:HGroup>
				
			</s:VGroup>
		</s:HGroup>
	</s:BorderContainer>
	
	<s:BorderContainer borderStyle="solid"	width="100%">
		<s:layout>
			<s:VerticalLayout gap="0"  paddingLeft="1" paddingBottom="1" paddingRight="1" paddingTop="1" />
		</s:layout>
		<s:CheckBox id="lineEnabled" label="{lang('Enable Borders')}" fontWeight="bold" 
					 toolTip="{lang('Check this box to enable borders around each shape.\nThis would typically be unchecked to have a more subtle mesh of colors on a map, rather than distinguished by borders between areas.')}"
					 creationComplete="linkBindableProperty(_plotter.line.enabled.defaultValue,event.target,'selected')"/>
		
		<s:HGroup verticalAlign="middle" >
			<s:VGroup enabled="{lineEnabled.selected}" gap="0">
				<s:Label text="{lang('Alpha:')}"/>
				<mx:NumericStepper 	id="lineAlpha" 
									minimum="0" maximum="1" stepSize="0.1"
									width="50"
									toolTip="{lang('Set the alpha (0: transparent, 1: opaque) of the borders around each shape.')}"
									creationComplete="linkBindableProperty(_plotter.line.alpha.defaultValue, event.target, 'value')"/>
			</s:VGroup>
			
			<s:VGroup enabled="{lineEnabled.selected}" gap="0">
				<s:Label text="{lang('Weight:')}"/>
				<mx:NumericStepper 	id="lineWeight" 
									minimum="1" maximum="10"
									width="50"
									toolTip="{lang('Set the thickness of the borders around each shape.')}"
									creationComplete="linkBindableProperty(_plotter.line.weight.defaultValue, event.target, 'value')"/>
			</s:VGroup>
			<s:VGroup enabled="{lineEnabled.selected}" gap="0">
				<s:Label text="{lang('Color:')}"/>
				<mx:ColorPicker id="lineColor"
								toolTip="{lang('Set the color used for the borders around each shape.')}" 
								creationComplete="linkBindableProperty(_plotter.line.color.defaultValue,event.target,'selectedColor')"/>
			</s:VGroup>
		</s:HGroup>
		<ui:NormalizedColumnComponent enabled="{lineEnabled.selected}" id="normalizedWeightComponent" label="Border Thickness"/>
	</s:BorderContainer>
	
	<s:BorderContainer borderStyle="solid" enabled="{!useImagesCheck.selected || fixedImageSizeCheck.selected}"  width="100%">
		<s:layout>
			<s:VerticalLayout gap="0"  paddingLeft="1" paddingBottom="1" paddingRight="1" paddingTop="1" horizontalAlign="center"  />
		</s:layout>
		<s:Label text="{lang('Icon size:')}"/>
		<mx:NumericStepper 	id="iconSize" 
							toolTip="{lang('Set the default icon size when point-based geometries are used.')}"
							minimum="0.2" maximum="60"
							width="50"
							creationComplete="linkBindableProperty(_plotter.iconSize, event.target, 'value')"/>
	</s:BorderContainer>
	<s:BorderContainer borderStyle="solid"  width="100%">
		<s:layout>
			<s:VerticalLayout gap="0"  paddingLeft="1" paddingBottom="1" paddingRight="1" paddingTop="1" horizontalAlign="center"  />
		</s:layout>
		<s:CheckBox id="useImagesCheck" label="{lang('Enable images for point data')}" click="handleGeomPlotterImageToggle()"/>
		<ui:IndentTextInput id="imageURL" label="{lang('Default image URL')}" creationComplete="EventUtils.addDelayedEventCallback(event.target, Event.CHANGE, handleGeomPlotterImageInput)" enabled="{useImagesCheck.selected}"/>
		<ui:DynamicColumnComponent id="imageURLColumnSelector" label="{lang('Image URL column')}" dynamicObject="{_plotter.pointDataImageColumn}"/>
		<s:CheckBox id="fixedImageSizeCheck" label="{lang('Use specified size')}" enabled="{useImagesCheck.selected}" creationComplete="linkBindableProperty(_plotter.useFixedImageSize, fixedImageSizeCheck, 'selected');"/>
	</s:BorderContainer>
	<s:HGroup>
		<s:CheckBox id="ignoreSubsetCheck" label="{lang('Ignore Subset')}" change="handleIgnoreSubsetCheck()"/>
		<ui:HelpComponent>
			Check this box to always display these geometries whether or not they are in the current subset.
			Fill color will only be displayed on the geometries in the current subset.  Only the borders will be displayed for the rest.
		</ui:HelpComponent>
	</s:HGroup>
	
	<fx:Script>
		<![CDATA[
			import weave.Weave;
			import weave.data.AttributeColumns.NormalizedColumn;
			import weave.api.core.ILinkableObject;
			import weave.api.getCallbackCollection;
			import weave.api.linkBindableProperty;
			import weave.compiler.StandardLib;
			import weave.data.AttributeColumns.AlwaysDefinedColumn;
			import weave.utils.EventUtils;
			import weave.visualization.plotters.GeometryPlotter;
			
			[Bindable] private var _plotter:GeometryPlotter = null;
			
			public function setTarget(object:ILinkableObject):void
			{
				_plotter = object as GeometryPlotter;
			}
			
			public function applyChanges():void
			{
				
			}			
			
			override protected function childrenCreated():void
			{
				super.childrenCreated();
				_plotter.pointDataImageColumn.addImmediateCallback(this, handleGeomPlotterImageURLChange);
				getCallbackCollection(_plotter.filteredKeySet).addImmediateCallback(this, handleSubsetChange, true);
				_plotter.pointDataImageColumn.addImmediateCallback(this, handleImageColumn, true);
				geometryComponent.dynamicObject = _plotter.geometryColumn.internalDynamicColumn;
				
				normalizedWeightComponent.normalizedColumn = _plotter.line.normalizedWeightColumn;
				
			}
			
			private function handleSolidFillColorCheck():void
			{
				var defaultColor:Number = StandardLib.asNumber(_plotter.fill.color.defaultValue.value);
				if (enableDefaultColor.selected)
				{
					_plotter.fill.color.defaultValue.value = fillColor.selectedColor;
				}
				else
				{
					_plotter.fill.color.defaultValue.value = NaN;
				}
			}
			
			private function handleFillColorSelected():void
			{
				// copy gui values to session state
				_plotter.fill.color.defaultValue.value = fillColor.selectedColor;
			}
			
			private function handleGeomPlotterImageToggle():void
			{
				if (!useImagesCheck.selected)
					_plotter.pointDataImageColumn.removeObject();
				else
					handleGeomPlotterImageInput();
			}
			
			private function handleGeomPlotterImageInput():void
			{
				var url:String = imageURL.text;
				var adc:AlwaysDefinedColumn = _plotter.pointDataImageColumn.requestLocalObject(AlwaysDefinedColumn, false);
				adc.defaultValue.value = url;
			}
			
			private function handleGeomPlotterImageURLChange():void
			{
				var adc:AlwaysDefinedColumn = _plotter.pointDataImageColumn.getInternalColumn() as AlwaysDefinedColumn;
				if (adc)
					imageURL.text = adc.defaultValue.value as String;
			}
			
			private function handleIgnoreSubsetCheck():void
			{
				if (ignoreSubsetCheck.selected)
				{
					_plotter.filteredKeySet.keyFilter.removeObject();
				}
				else
				{
					_plotter.filteredKeySet.keyFilter.globalName = Weave.DEFAULT_SUBSET_KEYFILTER;
				}
			}
			
			private function handleSubsetChange():void
			{
				ignoreSubsetCheck.selected = _plotter.filteredKeySet.keyFilter.globalName ? false : true;
			}
			
			private function handleImageColumn():void
			{
				useImagesCheck.selected = (_plotter.pointDataImageColumn.getInternalColumn() != null);
				var adc:AlwaysDefinedColumn = _plotter.pointDataImageColumn.getInternalColumn() as AlwaysDefinedColumn;
				if (adc)
					imageURL.text = adc.defaultValue.value as String;
			}
		]]>
	</fx:Script>
</s:NavigatorContent>
