<?xml version="1.0" encoding="utf-8"?>
<!--
/*
    Weave (Web-based Analysis and Visualization Environment)
    Copyright (C) 2008-2011 University of Massachusetts Lowell

    This file is a part of Weave.

    Weave is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License, Version 3,
    as published by the Free Software Foundation.

    Weave is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Weave.  If not, see <http://www.gnu.org/licenses/>.
*/
-->

<mx:VBox width="100%" height="100%"
	xmlns="weave.editors.*"
	xmlns:ui="weave.ui.*"
	xmlns:mx="http://www.adobe.com/2006/mxml"
	verticalScrollPolicy="off" horizontalScrollPolicy="off"
	implements="weave.api.core.ILinkableObject,weave.api.ui.ILinkableObjectEditor"
	>
	<ui:HierarchyExplorer id="explorer"/>
	<ui:BusyIndicator id="busyIndicator" targets="{[explorer]}"/>
	<mx:HBox id="dummyHBox" minWidth="0" width="100%"
			 borderColor="#000000" 
			 horizontalScrollPolicy="off" verticalScrollPolicy="off">
		<ui:TextInputWithPrompt id="folderSearchInput"
					  prompt="{lang('Search')}"
					  width="100%"/>
		<ui:TextInputWithPrompt id="fileSearchInput"
					  prompt="{lang('Search')}"
					  width="100%"/>
	</mx:HBox>
	
	<mx:Script>
		<![CDATA[
			import mx.binding.utils.BindingUtils;
			
			import weave.api.copySessionState;
			import weave.api.core.ILinkableHashMap;
			import weave.api.core.ILinkableObject;
			import weave.api.data.IColumnReference;
			import weave.api.data.IDataSource;
			import weave.api.data.IWeaveTreeNode;
			import weave.api.getCallbackCollection;
			import weave.api.linkBindableProperty;
			import weave.api.newLinkableChild;
			import weave.api.registerLinkableChild;
			import weave.compiler.Compiler;
			import weave.core.LinkableWatcher;
			import weave.core.UIUtils;
			import weave.data.AttributeColumns.DynamicColumn;
			import weave.data.AttributeColumns.ReferencedColumn;
			import weave.data.hierarchy.DataSourceTreeNode;
			import weave.utils.EventUtils;
			
			public const referencedColumn:ReferencedColumn = newLinkableChild(this, ReferencedColumn, copyToTarget);
			private function copyToTarget():void
			{
				if (target)
					target.requestLocalObjectCopy(referencedColumn);
			}
			
			private const targetWatcher:LinkableWatcher = newLinkableChild(this, LinkableWatcher, copyFromTarget);
			private function copyFromTarget():void
			{
				if (target && target.internalObject is ReferencedColumn)
				{
					var counter:uint = referencedColumn.triggerCounter;
					copySessionState(target.internalObject, referencedColumn);
					// make sure item gets selected even if referencedColumn did not change
					// because we may have previously cleared explorer.fileView.selectedItem
					if (counter == referencedColumn.triggerCounter)
						handleReferencedColumn();
				}
				else if (explorer && explorer.fileView)
					explorer.fileView.selectedItem = null;
			}
			
			public function get target():DynamicColumn
			{
				return targetWatcher.target as DynamicColumn;
			}
			
			public function setTarget(newTarget:ILinkableObject):void
			{
				targetWatcher.target = newTarget as DynamicColumn;
			}
			public function hasPendingChanges():Boolean { return false; }
			public function applyChanges():void { }
			
			public function set dataSource(ds:IDataSource):void
			{
				dataSourceWatcher.target = ds;
			}
			private const dataSourceWatcher:LinkableWatcher = newLinkableChild(this, LinkableWatcher, handleDataSource);
			private function handleDataSource():void
			{
				var ds:IDataSource = dataSourceWatcher.target as IDataSource;
				explorer.rootNode = ds ? ds.getHierarchyRoot() : null;
				explorer.folderView.showRoot = !!ds;
			}
			
			override protected function createChildren():void
			{
				super.createChildren();
				
				// remove the dummy because we don't want it on the screen
				removeChild(dummyHBox);
				
//				explorer.folderVBox.addChildAt(folderSearchInput, 0);
				explorer.fileVBox.addChildAt(fileSearchInput, 0);
				
				registerLinkableChild(this, explorer);

				explorer.rootNode = new DataSourceTreeNode();
				
				explorer.folderView.dragEnabled = false;
				explorer.fileView.dragEnabled = true;
				
				getCallbackCollection(explorer).addGroupedCallback(this, handleExplorerGroupedCallback);
				referencedColumn.addImmediateCallback(this, handleReferencedColumn, true);
				
				BindingUtils.bindSetter(handleSelection, explorer.fileView, 'selectedItem');
//				linkBindableProperty(explorer.folderFilter, folderSearchInput, 'text', 200);
				linkBindableProperty(explorer.fileFilter, fileSearchInput, 'text', 200);
			}
			
			override protected function updateDisplayList(unscaledWidth:Number, unscaledHeight:Number):void
			{
				super.updateDisplayList(unscaledWidth, unscaledHeight);
			}
			
			private function handleSelection(node:IWeaveTreeNode):void
			{
				// don't set session state if tree is not focused.
				if (!UIUtils.hasFocus(explorer.fileView))
					return;
				
				var ref:IColumnReference = explorer.fileView.selectedItem as IColumnReference;
				if (ref)
				{
					var meta:Object = ref.getColumnMetadata();
					if (meta)
					{
						var counter:uint = referencedColumn.triggerCounter;
						referencedColumn.setColumnReference(ref.getDataSource(), meta);
						// when user selects something, make sure we copy to target even if referencedColumn did not change
						if (counter == referencedColumn.triggerCounter)
							copyToTarget();
					}
				}
			}
			
			private function handleExplorerGroupedCallback():void
			{
				// If we have a target and nothing is selected, try to find the item in the newly updated hierarchy
				if (target && target.internalObject is ReferencedColumn && !explorer.fileView.selectedItem)
					handleReferencedColumn();
			}
			
			private function handleReferencedColumn():void
			{
				var ds:IDataSource = referencedColumn.getDataSource();
				if (ds)
				{
					var meta:Object = referencedColumn.metadata.getSessionState();
					var node:IWeaveTreeNode = ds.findHierarchyNode(meta);
					explorer.expandPathAndSelectNode(node);
				}
			}
			
			/**
			 * Adds multiple columns to an ILinkableHashMap.
			 * @param destination The hash map where columns should be added.
			 * @param selectedOnly If true, adds selected columns.  If false, adds all visible columns
			 * @return An Array of columns that were added to the hash map.
			 */
			public function addMultipleColumns(destination:ILinkableHashMap, selectedOnly:Boolean):Array
			{
				var result:Array = [];
				var folder:IWeaveTreeNode = explorer.folderView.selectedItem as IWeaveTreeNode;
				if (!folder)
					return result;
				
				var nodes:Array;
				if (selectedOnly)
				{
					nodes = explorer.fileView.selectedItems;
					// selectedItems order is reversed
					if (nodes)
						nodes = nodes.concat().reverse();
				}
				else
				{
					nodes = folder.getChildren();
				}
				
				referencedColumn.delayCallbacks();
				getCallbackCollection(destination).delayCallbacks();
				for each (var node:IWeaveTreeNode in nodes)
				{
					var ref:IColumnReference = node as IColumnReference;
					if (ref)
					{
						var meta:Object = ref.getColumnMetadata();
						if (meta !== null)
						{
							referencedColumn.setColumnReference(ref.getDataSource(), meta);
							result.push(destination.requestObjectCopy(null, referencedColumn));
						}
					}
				}
				getCallbackCollection(destination).resumeCallbacks();
				referencedColumn.resumeCallbacks();
				
				return result;
			}
			
			public function clearSearch():void
			{
				fileSearchInput.text = '';
				folderSearchInput.text = '';
				
				explorer.fileFilter.value = '';
//				explorer.folderFilter.value = '';
			}
		]]>
	</mx:Script>
</mx:VBox>
